import { Mutex } from "@livekit/mutex";
import { open, stat } from "node:fs/promises";
import {
  ByteStreamWriter,
  TextStreamWriter
} from "./data_streams/index.js";
import { FfiClient, FfiHandle } from "./ffi_client.js";
import { log } from "./log.js";
import {
  DisconnectReason,
  ParticipantKind
} from "./proto/participant_pb.js";
import {
  DataStream_ByteHeader,
  DataStream_Chunk,
  DataStream_Header,
  DataStream_OperationType,
  DataStream_TextHeader,
  DataStream_Trailer,
  SendStreamChunkRequest,
  SendStreamHeaderRequest,
  SendStreamTrailerRequest
} from "./proto/room_pb.js";
import { ChatMessage as ChatMessageModel } from "./proto/room_pb.js";
import {
  EditChatMessageRequest,
  TranscriptionSegment as ProtoTranscriptionSegment,
  PublishDataRequest,
  PublishSipDtmfRequest,
  PublishTrackRequest,
  PublishTranscriptionRequest,
  SendChatMessageRequest,
  SetLocalAttributesRequest,
  SetLocalMetadataRequest,
  SetLocalNameRequest,
  UnpublishTrackRequest
} from "./proto/room_pb.js";
import {
  PerformRpcRequest,
  RegisterRpcMethodRequest,
  RpcMethodInvocationResponseRequest,
  UnregisterRpcMethodRequest
} from "./proto/rpc_pb.js";
import { RpcError } from "./rpc.js";
import { LocalTrackPublication } from "./track_publication.js";
import { numberToBigInt, splitUtf8 } from "./utils.js";
const STREAM_CHUNK_SIZE = 15e3;
class Participant {
  constructor(owned_info) {
    this.trackPublications = /* @__PURE__ */ new Map();
    this.info = owned_info.info;
    this.ffi_handle = new FfiHandle(owned_info.handle.id);
  }
  get sid() {
    return this.info.sid;
  }
  get name() {
    return this.info.name;
  }
  get identity() {
    return this.info.identity ?? "";
  }
  get metadata() {
    return this.info.metadata ?? "";
  }
  get attributes() {
    return this.info.attributes ?? {};
  }
  get kind() {
    return this.info.kind ?? ParticipantKind.STANDARD;
  }
  get disconnectReason() {
    if (this.info.disconnectReason === DisconnectReason.UNKNOWN_REASON) {
      return void 0;
    }
    return this.info.disconnectReason;
  }
}
class LocalParticipant extends Participant {
  constructor() {
    super(...arguments);
    this.rpcHandlers = /* @__PURE__ */ new Map();
    this.trackPublications = /* @__PURE__ */ new Map();
  }
  async publishData(data, options) {
    const req = new PublishDataRequest({
      localParticipantHandle: this.ffi_handle.handle,
      dataPtr: FfiClient.instance.retrievePtr(data),
      dataLen: BigInt(data.byteLength),
      reliable: options.reliable,
      topic: options.topic,
      destinationIdentities: options.destination_identities
    });
    const res = FfiClient.instance.request({
      message: { case: "publishData", value: req }
    });
    const cb = await FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "publishData" && ev.message.value.asyncId == res.asyncId;
    });
    if (cb.error) {
      throw new Error(cb.error);
    }
  }
  async publishDtmf(code, digit) {
    const req = new PublishSipDtmfRequest({
      localParticipantHandle: this.ffi_handle.handle,
      code,
      digit
    });
    const res = FfiClient.instance.request({
      message: { case: "publishSipDtmf", value: req }
    });
    const cb = await FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "publishSipDtmf" && ev.message.value.asyncId == res.asyncId;
    });
    if (cb.error) {
      throw new Error(cb.error);
    }
  }
  async publishTranscription(transcription) {
    const req = new PublishTranscriptionRequest({
      localParticipantHandle: this.ffi_handle.handle,
      participantIdentity: transcription.participantIdentity,
      segments: transcription.segments.map(
        (s) => new ProtoTranscriptionSegment({
          id: s.id,
          text: s.text,
          startTime: s.startTime,
          endTime: s.endTime,
          final: s.final,
          language: s.language
        })
      ),
      trackId: transcription.trackSid
    });
    const res = FfiClient.instance.request({
      message: { case: "publishTranscription", value: req }
    });
    const cb = await FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "publishTranscription" && ev.message.value.asyncId == res.asyncId;
    });
    if (cb.error) {
      throw new Error(cb.error);
    }
  }
  async updateMetadata(metadata) {
    const req = new SetLocalMetadataRequest({
      localParticipantHandle: this.ffi_handle.handle,
      metadata
    });
    const res = FfiClient.instance.request({
      message: { case: "setLocalMetadata", value: req }
    });
    await FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "setLocalMetadata" && ev.message.value.asyncId == res.asyncId;
    });
  }
  /**
   * Returns a `StreamWriter` instance that allows to write individual chunks of text to a stream.
   * Well suited for TTS and/or streaming LLM output. If you want to simply send a text then use sendText() instead
   */
  async streamText(options) {
    const senderIdentity = this.identity;
    const streamId = (options == null ? void 0 : options.streamId) ?? crypto.randomUUID();
    const destinationIdentities = options == null ? void 0 : options.destinationIdentities;
    const info = {
      streamId,
      mimeType: "text/plain",
      topic: (options == null ? void 0 : options.topic) ?? "",
      timestamp: Date.now()
    };
    const headerReq = new SendStreamHeaderRequest({
      senderIdentity,
      destinationIdentities,
      localParticipantHandle: this.ffi_handle.handle,
      header: new DataStream_Header({
        streamId,
        mimeType: info.mimeType,
        topic: info.topic,
        timestamp: numberToBigInt(info.timestamp),
        attributes: options == null ? void 0 : options.attributes,
        contentHeader: {
          case: "textHeader",
          value: new DataStream_TextHeader({
            operationType: DataStream_OperationType.CREATE,
            version: 0,
            replyToStreamId: "",
            generated: false
          })
        }
      })
    });
    await this.sendStreamHeader(headerReq);
    let nextChunkId = 0;
    const localHandle = this.ffi_handle.handle;
    const sendTrailer = this.sendStreamTrailer;
    const sendChunk = this.sendStreamChunk;
    const writableStream = new WritableStream({
      // Implement the sink
      async write(text) {
        for (const textByteChunk of splitUtf8(text, STREAM_CHUNK_SIZE)) {
          const chunkRequest = new SendStreamChunkRequest({
            senderIdentity,
            localParticipantHandle: localHandle,
            destinationIdentities,
            chunk: new DataStream_Chunk({
              content: textByteChunk,
              streamId,
              chunkIndex: numberToBigInt(nextChunkId)
            })
          });
          await sendChunk(chunkRequest);
          nextChunkId += 1;
        }
      },
      async close() {
        const trailerReq = new SendStreamTrailerRequest({
          senderIdentity,
          localParticipantHandle: localHandle,
          destinationIdentities,
          trailer: new DataStream_Trailer({
            streamId,
            reason: ""
          })
        });
        await sendTrailer(trailerReq);
      },
      abort(err) {
        log.error("Sink error:", err);
      }
    });
    const writer = new TextStreamWriter(writableStream, info);
    return writer;
  }
  async sendText(text, options) {
    const writer = await this.streamText(options);
    await writer.write(text);
    await writer.close();
    return writer.info;
  }
  async streamBytes(options) {
    const senderIdentity = this.identity;
    const streamId = (options == null ? void 0 : options.streamId) ?? crypto.randomUUID();
    const destinationIdentities = options == null ? void 0 : options.destinationIdentities;
    const info = {
      streamId,
      mimeType: (options == null ? void 0 : options.mimeType) ?? "application/octet-stream",
      topic: (options == null ? void 0 : options.topic) ?? "",
      timestamp: Date.now(),
      attributes: options == null ? void 0 : options.attributes,
      totalSize: options == null ? void 0 : options.totalSize,
      name: (options == null ? void 0 : options.name) ?? "unknown"
    };
    const headerReq = new SendStreamHeaderRequest({
      senderIdentity,
      destinationIdentities,
      localParticipantHandle: this.ffi_handle.handle,
      header: new DataStream_Header({
        streamId,
        mimeType: info.mimeType,
        topic: info.topic,
        timestamp: numberToBigInt(info.timestamp),
        attributes: info.attributes,
        totalLength: numberToBigInt(info.totalSize),
        contentHeader: {
          case: "byteHeader",
          value: new DataStream_ByteHeader({
            name: info.name
          })
        }
      })
    });
    await this.sendStreamHeader(headerReq);
    let chunkId = 0;
    const localHandle = this.ffi_handle.handle;
    const sendTrailer = this.sendStreamTrailer;
    const sendChunk = this.sendStreamChunk;
    const writeMutex = new Mutex();
    const writableStream = new WritableStream({
      async write(chunk) {
        const unlock = await writeMutex.lock();
        let byteOffset = 0;
        try {
          while (byteOffset < chunk.byteLength) {
            const subChunk = chunk.slice(byteOffset, byteOffset + STREAM_CHUNK_SIZE);
            const chunkRequest = new SendStreamChunkRequest({
              senderIdentity,
              localParticipantHandle: localHandle,
              destinationIdentities,
              chunk: new DataStream_Chunk({
                content: subChunk,
                streamId,
                chunkIndex: numberToBigInt(chunkId)
              })
            });
            await sendChunk(chunkRequest);
            chunkId += 1;
            byteOffset += subChunk.byteLength;
          }
        } finally {
          unlock();
        }
      },
      async close() {
        const trailerReq = new SendStreamTrailerRequest({
          senderIdentity,
          localParticipantHandle: localHandle,
          destinationIdentities,
          trailer: new DataStream_Trailer({
            streamId,
            reason: ""
          })
        });
        await sendTrailer(trailerReq);
      },
      abort(err) {
        log.error("Sink error:", err);
      }
    });
    const byteWriter = new ByteStreamWriter(writableStream, info);
    return byteWriter;
  }
  /** Sends a file provided as PathLike to specified recipients */
  async sendFile(path, options) {
    const fileStats = await stat(path);
    const file = await open(path);
    try {
      const stream = file.readableWebStream({ type: "bytes" });
      const streamId = crypto.randomUUID();
      const destinationIdentities = options == null ? void 0 : options.destinationIdentities;
      const writer = await this.streamBytes({
        streamId,
        name: options == null ? void 0 : options.name,
        totalSize: fileStats.size,
        destinationIdentities,
        topic: options == null ? void 0 : options.topic,
        mimeType: options == null ? void 0 : options.mimeType,
        attributes: options == null ? void 0 : options.attributes
      });
      for await (const chunk of stream) {
        await writer.write(chunk);
      }
      await writer.close();
    } finally {
      await file.close();
    }
  }
  async sendStreamHeader(req) {
    const type = "sendStreamHeader";
    const res = FfiClient.instance.request({
      message: { case: type, value: req }
    });
    const cb = await FfiClient.instance.waitFor((ev) => {
      return ev.message.case == type && ev.message.value.asyncId == res.asyncId;
    });
    if (cb.error) {
      throw new Error(cb.error);
    }
  }
  async sendStreamChunk(req) {
    const type = "sendStreamChunk";
    const res = FfiClient.instance.request({
      message: { case: type, value: req }
    });
    const cb = await FfiClient.instance.waitFor((ev) => {
      return ev.message.case == type && ev.message.value.asyncId == res.asyncId;
    });
    if (cb.error) {
      throw new Error(cb.error);
    }
  }
  async sendStreamTrailer(req) {
    const type = "sendStreamTrailer";
    const res = FfiClient.instance.request({
      message: { case: type, value: req }
    });
    const cb = await FfiClient.instance.waitFor((ev) => {
      return ev.message.case == type && ev.message.value.asyncId == res.asyncId;
    });
    if (cb.error) {
      throw new Error(cb.error);
    }
  }
  /**
   * Sends a chat message to participants in the room
   *
   * @param text - The text content of the chat message.
   * @param destinationIdentities - An optional array of recipient identities to whom the message will be sent. If omitted, the message is broadcast to all participants.
   * @param senderIdentity - An optional identity of the sender. If omitted, the default sender identity is used.
   *
   */
  async sendChatMessage(text, destinationIdentities, senderIdentity) {
    const req = new SendChatMessageRequest({
      localParticipantHandle: this.ffi_handle.handle,
      message: text,
      destinationIdentities,
      senderIdentity
    });
    const res = FfiClient.instance.request({
      message: { case: "sendChatMessage", value: req }
    });
    const cb = await FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "chatMessage" && ev.message.value.asyncId == res.asyncId;
    });
    switch (cb.message.case) {
      case "chatMessage":
        const { id, timestamp, editTimestamp, message } = cb.message.value;
        return {
          id,
          timestamp: Number(timestamp),
          editTimestamp: Number(editTimestamp),
          message
        };
      case "error":
      default:
        throw new Error(cb.message.value);
    }
  }
  /**
   * @experimental
   */
  async editChatMessage(editText, originalMessage, destinationIdentities, senderIdentity) {
    const req = new EditChatMessageRequest({
      localParticipantHandle: this.ffi_handle.handle,
      editText,
      originalMessage: new ChatMessageModel({
        ...originalMessage,
        timestamp: BigInt(originalMessage.timestamp),
        editTimestamp: originalMessage.editTimestamp ? BigInt(originalMessage.editTimestamp) : void 0
      }),
      destinationIdentities,
      senderIdentity
    });
    const res = FfiClient.instance.request({
      message: { case: "editChatMessage", value: req }
    });
    const cb = await FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "chatMessage" && ev.message.value.asyncId == res.asyncId;
    });
    switch (cb.message.case) {
      case "chatMessage":
        const { id, timestamp, editTimestamp, message } = cb.message.value;
        return {
          id,
          timestamp: Number(timestamp),
          editTimestamp: Number(editTimestamp),
          message
        };
      case "error":
      default:
        throw new Error(cb.message.value);
    }
  }
  async updateName(name) {
    const req = new SetLocalNameRequest({
      localParticipantHandle: this.ffi_handle.handle,
      name
    });
    const res = FfiClient.instance.request({
      message: { case: "setLocalName", value: req }
    });
    await FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "setLocalName" && ev.message.value.asyncId == res.asyncId;
    });
  }
  async setAttributes(attributes) {
    const req = new SetLocalAttributesRequest({
      localParticipantHandle: this.ffi_handle.handle,
      attributes: Object.entries(attributes).map(([key, value]) => ({ key, value }))
    });
    const res = FfiClient.instance.request({
      message: { case: "setLocalAttributes", value: req }
    });
    await FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "setLocalAttributes" && ev.message.value.asyncId == res.asyncId;
    });
  }
  async publishTrack(track, options) {
    const req = new PublishTrackRequest({
      localParticipantHandle: this.ffi_handle.handle,
      trackHandle: track.ffi_handle.handle,
      options
    });
    const res = FfiClient.instance.request({
      message: { case: "publishTrack", value: req }
    });
    const cb = await FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "publishTrack" && ev.message.value.asyncId == res.asyncId;
    });
    switch (cb.message.case) {
      case "publication":
        const track_publication = new LocalTrackPublication(cb.message.value);
        track_publication.track = track;
        this.trackPublications.set(track_publication.sid, track_publication);
        return track_publication;
      case "error":
      default:
        throw new Error(cb.message.value);
    }
  }
  async unpublishTrack(trackSid, stopOnUnpublish) {
    const req = new UnpublishTrackRequest({
      localParticipantHandle: this.ffi_handle.handle,
      trackSid,
      stopOnUnpublish: stopOnUnpublish ?? true
    });
    const res = FfiClient.instance.request({
      message: { case: "unpublishTrack", value: req }
    });
    const cb = await FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "unpublishTrack" && ev.message.value.asyncId == res.asyncId;
    });
    if (cb.error) {
      throw new Error(cb.error);
    }
    const pub = this.trackPublications.get(trackSid);
    if (pub) {
      pub.track = void 0;
    }
    this.trackPublications.delete(trackSid);
  }
  /**
   * Initiate an RPC call to a remote participant.
   * @param params - Parameters for initiating the RPC call, see {@link PerformRpcParams}
   * @returns A promise that resolves with the response payload or rejects with an error.
   * @throws Error on failure. Details in `message`.
   */
  async performRpc({
    destinationIdentity,
    method,
    payload,
    responseTimeout
  }) {
    const req = new PerformRpcRequest({
      localParticipantHandle: this.ffi_handle.handle,
      destinationIdentity,
      method,
      payload,
      responseTimeoutMs: responseTimeout
    });
    const res = FfiClient.instance.request({
      message: { case: "performRpc", value: req }
    });
    const cb = await FfiClient.instance.waitFor((ev) => {
      return ev.message.case === "performRpc" && ev.message.value.asyncId === res.asyncId;
    });
    if (cb.error) {
      throw RpcError.fromProto(cb.error);
    }
    return cb.payload;
  }
  /**
   * Establishes the participant as a receiver for calls of the specified RPC method.
   * Will overwrite any existing callback for the same method.
   *
   * @param method - The name of the indicated RPC method
   * @param handler - Will be invoked when an RPC request for this method is received
   * @returns A promise that resolves when the method is successfully registered
   *
   * @example
   * ```typescript
   * room.localParticipant?.registerRpcMethod(
   *   'greet',
   *   async (data: RpcInvocationData) => {
   *     console.log(`Received greeting from ${data.callerIdentity}: ${data.payload}`);
   *     return `Hello, ${data.callerIdentity}!`;
   *   }
   * );
   * ```
   *
   * See {@link RpcInvocationData} for more details on invocation params.
   *
   * The handler should return a Promise that resolves to a string.
   * If unable to respond within `responseTimeout`, the request will result in an error on the caller's side.
   *
   * You may throw errors of type `RpcError` with a string `message` in the handler,
   * and they will be received on the caller's side with the message intact.
   * Other errors thrown in your handler will not be transmitted as-is, and will instead arrive to the caller as `1500` ("Application Error").
   */
  registerRpcMethod(method, handler) {
    this.rpcHandlers.set(method, handler);
    const req = new RegisterRpcMethodRequest({
      localParticipantHandle: this.ffi_handle.handle,
      method
    });
    FfiClient.instance.request({
      message: { case: "registerRpcMethod", value: req }
    });
  }
  /**
   * Unregisters a previously registered RPC method.
   *
   * @param method - The name of the RPC method to unregister
   */
  unregisterRpcMethod(method) {
    this.rpcHandlers.delete(method);
    const req = new UnregisterRpcMethodRequest({
      localParticipantHandle: this.ffi_handle.handle,
      method
    });
    FfiClient.instance.request({
      message: { case: "unregisterRpcMethod", value: req }
    });
  }
  /** @internal */
  async handleRpcMethodInvocation(invocationId, method, requestId, callerIdentity, payload, responseTimeout) {
    let responseError = null;
    let responsePayload = null;
    const handler = this.rpcHandlers.get(method);
    if (!handler) {
      responseError = RpcError.builtIn("UNSUPPORTED_METHOD");
    } else {
      try {
        responsePayload = await handler({ requestId, callerIdentity, payload, responseTimeout });
      } catch (error) {
        if (error instanceof RpcError) {
          responseError = error;
        } else {
          console.warn(
            `Uncaught error returned by RPC handler for ${method}. Returning APPLICATION_ERROR instead.`,
            error
          );
          responseError = RpcError.builtIn("APPLICATION_ERROR");
        }
      }
    }
    const req = new RpcMethodInvocationResponseRequest({
      localParticipantHandle: this.ffi_handle.handle,
      invocationId,
      error: responseError ? responseError.toProto() : void 0,
      payload: responsePayload ?? void 0
    });
    const res = FfiClient.instance.request({
      message: { case: "rpcMethodInvocationResponse", value: req }
    });
    if (res.error) {
      console.warn(`error sending rpc method invocation response: ${res.error}`);
    }
  }
}
class RemoteParticipant extends Participant {
  constructor(owned_info) {
    super(owned_info);
    this.trackPublications = /* @__PURE__ */ new Map();
  }
}
export {
  LocalParticipant,
  Participant,
  RemoteParticipant
};
//# sourceMappingURL=participant.js.map