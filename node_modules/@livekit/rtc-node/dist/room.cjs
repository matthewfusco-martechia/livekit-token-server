"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var room_exports = {};
__export(room_exports, {
  ConnectError: () => ConnectError,
  Room: () => Room,
  RoomEvent: () => RoomEvent,
  defaultRoomOptions: () => defaultRoomOptions,
  defaultRtcConfiguration: () => defaultRtcConfiguration
});
module.exports = __toCommonJS(room_exports);
var import_events = __toESM(require("events"), 1);
var import_web = require("node:stream/web");
var import_stream_reader = require("./data_streams/stream_reader.cjs");
var import_e2ee = require("./e2ee.cjs");
var import_ffi_client = require("./ffi_client.cjs");
var import_log = require("./log.cjs");
var import_participant = require("./participant.cjs");
var import_e2ee_pb = require("./proto/e2ee_pb.cjs");
var import_room_pb = require("./proto/room_pb.cjs");
var import_track_pb = require("./proto/track_pb.cjs");
var import_track = require("./track.cjs");
var import_track_publication = require("./track_publication.cjs");
var import_utils = require("./utils.cjs");
const defaultRtcConfiguration = {
  iceTransportType: import_room_pb.IceTransportType.TRANSPORT_ALL,
  continualGatheringPolicy: import_room_pb.ContinualGatheringPolicy.GATHER_CONTINUALLY,
  iceServers: []
};
const defaultRoomOptions = new import_room_pb.RoomOptions({
  autoSubscribe: true,
  dynacast: false,
  e2ee: void 0,
  rtcConfig: void 0,
  adaptiveStream: false,
  joinRetries: 1
});
class Room extends import_events.default {
  constructor() {
    super();
    this.byteStreamControllers = /* @__PURE__ */ new Map();
    this.textStreamControllers = /* @__PURE__ */ new Map();
    this.byteStreamHandlers = /* @__PURE__ */ new Map();
    this.textStreamHandlers = /* @__PURE__ */ new Map();
    this.connectionState = import_room_pb.ConnectionState.CONN_DISCONNECTED;
    this.remoteParticipants = /* @__PURE__ */ new Map();
    this.onFfiEvent = (ffiEvent) => {
      if (!this.localParticipant || !this.ffiHandle || !this.info) {
        throw TypeError("cannot handle ffi events before connectCallback");
      }
      if (ffiEvent.message.case == "rpcMethodInvocation") {
        if (ffiEvent.message.value.localParticipantHandle == this.localParticipant.ffi_handle.handle) {
          this.localParticipant.handleRpcMethodInvocation(
            ffiEvent.message.value.invocationId,
            ffiEvent.message.value.method,
            ffiEvent.message.value.requestId,
            ffiEvent.message.value.callerIdentity,
            ffiEvent.message.value.payload,
            ffiEvent.message.value.responseTimeoutMs
          );
        }
        return;
      } else if (ffiEvent.message.case != "roomEvent" || ffiEvent.message.value.roomHandle != this.ffiHandle.handle) {
        return;
      }
      const ev = ffiEvent.message.value.message;
      if (ev.case == "participantConnected") {
        const participant = this.createRemoteParticipant(ev.value.info);
        this.remoteParticipants.set(participant.identity, participant);
        this.emit("participantConnected" /* ParticipantConnected */, participant);
      } else if (ev.case == "participantDisconnected") {
        const participant = this.remoteParticipants.get(ev.value.participantIdentity);
        this.remoteParticipants.delete(participant.identity);
        participant.info.disconnectReason = ev.value.disconnectReason;
        this.emit("participantDisconnected" /* ParticipantDisconnected */, participant);
      } else if (ev.case == "localTrackPublished") {
        const publication = this.localParticipant.trackPublications.get(ev.value.trackSid);
        this.emit("localTrackPublished" /* LocalTrackPublished */, publication, this.localParticipant);
      } else if (ev.case == "localTrackUnpublished") {
        const publication = this.localParticipant.trackPublications.get(ev.value.publicationSid);
        this.localParticipant.trackPublications.delete(ev.value.publicationSid);
        this.emit("localTrackUnpublished" /* LocalTrackUnpublished */, publication, this.localParticipant);
      } else if (ev.case == "localTrackSubscribed") {
        const publication = this.localParticipant.trackPublications.get(ev.value.trackSid);
        publication.resolveFirstSubscription();
        this.emit("localTrackSubscribed" /* LocalTrackSubscribed */, publication.track);
      } else if (ev.case == "trackPublished") {
        const participant = this.remoteParticipants.get(ev.value.participantIdentity);
        const publication = new import_track_publication.RemoteTrackPublication(ev.value.publication);
        participant.trackPublications.set(publication.sid, publication);
        this.emit("trackPublished" /* TrackPublished */, publication, participant);
      } else if (ev.case == "trackUnpublished") {
        const participant = this.requireRemoteParticipant(ev.value.participantIdentity);
        const publication = participant.trackPublications.get(ev.value.publicationSid);
        participant.trackPublications.delete(ev.value.publicationSid);
        if (publication) {
          this.emit("trackUnpublished" /* TrackUnpublished */, publication, participant);
        }
      } else if (ev.case == "trackSubscribed") {
        const ownedTrack = ev.value.track;
        const trackInfo = ownedTrack.info;
        const { participant, publication } = this.requirePublicationOfRemoteParticipant(
          ev.value.participantIdentity,
          trackInfo.sid
        );
        publication.subscribed = true;
        if (trackInfo.kind == import_track_pb.TrackKind.KIND_VIDEO) {
          publication.track = new import_track.RemoteVideoTrack(ownedTrack);
        } else if (trackInfo.kind == import_track_pb.TrackKind.KIND_AUDIO) {
          publication.track = new import_track.RemoteAudioTrack(ownedTrack);
        }
        this.emit("trackSubscribed" /* TrackSubscribed */, publication.track, publication, participant);
      } else if (ev.case == "trackUnsubscribed") {
        const { participant, publication } = this.requirePublicationOfRemoteParticipant(
          ev.value.participantIdentity,
          ev.value.trackSid
        );
        const track = publication.track;
        publication.track = void 0;
        publication.subscribed = false;
        this.emit("trackUnsubscribed" /* TrackUnsubscribed */, track, publication, participant);
      } else if (ev.case == "trackSubscriptionFailed") {
        const participant = this.requireRemoteParticipant(ev.value.participantIdentity);
        this.emit("trackSubscriptionFailed" /* TrackSubscriptionFailed */, ev.value.trackSid, participant, ev.value.error);
      } else if (ev.case == "trackMuted") {
        const { participant, publication } = this.requirePublicationOfParticipant(
          ev.value.participantIdentity,
          ev.value.trackSid
        );
        publication.info.muted = true;
        if (publication.track) {
          publication.track.info.muted = true;
        }
        this.emit("trackMuted" /* TrackMuted */, publication, participant);
      } else if (ev.case == "trackUnmuted") {
        const { participant, publication } = this.requirePublicationOfParticipant(
          ev.value.participantIdentity,
          ev.value.trackSid
        );
        publication.info.muted = false;
        if (publication.track) {
          publication.track.info.muted = false;
        }
        this.emit("trackUnmuted" /* TrackUnmuted */, publication, participant);
      } else if (ev.case == "activeSpeakersChanged") {
        const activeSpeakers = ev.value.participantIdentities.map(
          (identity) => this.requireParticipantByIdentity(identity)
        );
        this.emit("activeSpeakersChanged" /* ActiveSpeakersChanged */, activeSpeakers);
      } else if (ev.case == "roomMetadataChanged") {
        this.info.metadata = ev.value.metadata;
        this.emit("roomMetadataChanged" /* RoomMetadataChanged */, this.info.metadata);
      } else if (ev.case == "participantMetadataChanged") {
        const participant = this.requireParticipantByIdentity(ev.value.participantIdentity);
        participant.info.metadata = ev.value.metadata;
        this.emit("participantMetadataChanged" /* ParticipantMetadataChanged */, participant.metadata, participant);
      } else if (ev.case == "participantNameChanged") {
        const participant = this.requireParticipantByIdentity(ev.value.participantIdentity);
        participant.info.name = ev.value.name;
        this.emit("participantNameChanged" /* ParticipantNameChanged */, participant.name, participant);
      } else if (ev.case == "participantAttributesChanged") {
        const participant = this.requireParticipantByIdentity(ev.value.participantIdentity);
        participant.info.attributes = ev.value.attributes.reduce(
          (acc, value) => {
            acc[value.key] = value.value;
            return acc;
          },
          {}
        );
        if (Object.keys(ev.value.changedAttributes).length > 0) {
          const changedAttributes = ev.value.changedAttributes.reduce(
            (acc, value) => {
              acc[value.key] = value.value;
              return acc;
            },
            {}
          );
          this.emit("participantAttributesChanged" /* ParticipantAttributesChanged */, changedAttributes, participant);
        }
      } else if (ev.case == "connectionQualityChanged") {
        const participant = this.requireParticipantByIdentity(ev.value.participantIdentity);
        this.emit("connectionQualityChanged" /* ConnectionQualityChanged */, ev.value.quality, participant);
      } else if (ev.case == "chatMessage") {
        const participant = this.retrieveParticipantByIdentity(ev.value.participantIdentity);
        const { id, message: messageText, timestamp, editTimestamp, generated } = ev.value.message;
        const message = {
          id,
          message: messageText,
          timestamp: Number(timestamp),
          editTimestamp: Number(editTimestamp),
          generated
        };
        this.emit("chatMessage" /* ChatMessage */, message, participant);
      } else if (ev.case == "dataPacketReceived") {
        const participant = this.remoteParticipants.get(ev.value.participantIdentity);
        const dataPacket = ev.value.value;
        switch (dataPacket.case) {
          case "user":
            const buffer = import_ffi_client.FfiClient.instance.copyBuffer(
              dataPacket.value.data.data.dataPtr,
              Number(dataPacket.value.data.data.dataLen)
            );
            new import_ffi_client.FfiHandle(dataPacket.value.data.handle.id).dispose();
            this.emit(
              "dataReceived" /* DataReceived */,
              buffer,
              participant,
              ev.value.kind,
              dataPacket.value.topic
            );
            break;
          case "sipDtmf":
            const { code, digit } = dataPacket.value;
            this.emit("dtmfReceived" /* DtmfReceived */, code, digit, participant);
            break;
          default:
            break;
        }
      } else if (ev.case == "e2eeStateChanged") {
        if (ev.value.state == import_e2ee_pb.EncryptionState.INTERNAL_ERROR) {
          this.emit("encryptionError" /* EncryptionError */, new Error("internal server error"));
        }
      } else if (ev.case == "connectionStateChanged") {
        this.connectionState = ev.value.state;
        this.emit("connectionStateChanged" /* ConnectionStateChanged */, this.connectionState);
      } else if (ev.case == "disconnected") {
        this.emit("disconnected" /* Disconnected */, ev.value.reason);
      } else if (ev.case == "reconnecting") {
        this.emit("reconnecting" /* Reconnecting */);
      } else if (ev.case == "reconnected") {
        this.emit("reconnected" /* Reconnected */);
      } else if (ev.case == "roomSidChanged") {
        this.emit("roomSidChanged" /* RoomSidChanged */, ev.value.sid);
      } else if (ev.case === "streamHeaderReceived" && ev.value.header) {
        this.handleStreamHeader(ev.value.header, ev.value.participantIdentity);
      } else if (ev.case === "streamChunkReceived" && ev.value.chunk) {
        this.handleStreamChunk(ev.value.chunk);
      } else if (ev.case === "streamTrailerReceived" && ev.value.trailer) {
        this.handleStreamTrailer(ev.value.trailer);
      }
    };
  }
  get name() {
    var _a;
    return (_a = this.info) == null ? void 0 : _a.name;
  }
  get metadata() {
    var _a;
    return (_a = this.info) == null ? void 0 : _a.metadata;
  }
  get isConnected() {
    return this.ffiHandle != void 0 && this.connectionState != import_room_pb.ConnectionState.CONN_DISCONNECTED;
  }
  async getSid() {
    var _a;
    if (!this.isConnected) {
      return "";
    }
    if (((_a = this.info) == null ? void 0 : _a.sid) && this.info.sid !== "") {
      return this.info.sid;
    }
    return new Promise((resolve, reject) => {
      const handleRoomUpdate = (sid) => {
        if (sid !== "") {
          this.off("roomSidChanged" /* RoomSidChanged */, handleRoomUpdate);
          resolve(sid);
        }
      };
      this.on("roomSidChanged" /* RoomSidChanged */, handleRoomUpdate);
      this.once("disconnected" /* Disconnected */, () => {
        this.off("roomSidChanged" /* RoomSidChanged */, handleRoomUpdate);
        reject("Room disconnected before room server id was available");
      });
    });
  }
  async connect(url, token, opts) {
    const options = { ...defaultRoomOptions, ...opts };
    const e2eeOptions = { ...import_e2ee.defaultE2EEOptions, ...options.e2ee };
    const req = new import_room_pb.ConnectRequest({
      url,
      token,
      options
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: {
        case: "connect",
        value: req
      }
    });
    const cb = await import_ffi_client.FfiClient.instance.waitFor((ev) => {
      return ev.message.case == "connect" && ev.message.value.asyncId == res.asyncId;
    });
    switch (cb.message.case) {
      case "result":
        this.ffiHandle = new import_ffi_client.FfiHandle(cb.message.value.room.handle.id);
        this.e2eeManager = options.e2ee && new import_e2ee.E2EEManager(this.ffiHandle.handle, e2eeOptions);
        this.info = cb.message.value.room.info;
        this.connectionState = import_room_pb.ConnectionState.CONN_CONNECTED;
        this.localParticipant = new import_participant.LocalParticipant(cb.message.value.localParticipant);
        for (const pt of cb.message.value.participants) {
          const rp = this.createRemoteParticipant(pt.participant);
          for (const pub of pt.publications) {
            const publication = new import_track_publication.RemoteTrackPublication(pub);
            rp.trackPublications.set(publication.sid, publication);
          }
        }
        import_ffi_client.FfiClient.instance.on(import_ffi_client.FfiClientEvent.FfiEvent, this.onFfiEvent);
        break;
      case "error":
      default:
        throw new ConnectError(cb.message.value || "");
    }
  }
  async disconnect() {
    var _a;
    if (!this.isConnected) {
      return;
    }
    import_ffi_client.FfiClient.instance.request({
      message: {
        case: "disconnect",
        value: {
          roomHandle: (_a = this.ffiHandle) == null ? void 0 : _a.handle
        }
      }
    });
    import_ffi_client.FfiClient.instance.removeListener(import_ffi_client.FfiClientEvent.FfiEvent, this.onFfiEvent);
    this.removeAllListeners();
  }
  registerTextStreamHandler(topic, callback) {
    if (this.textStreamHandlers.has(topic)) {
      throw new Error(`A text stream handler for topic "${topic}" has already been set.`);
    }
    this.textStreamHandlers.set(topic, callback);
  }
  unregisterTextStreamHandler(topic) {
    this.textStreamHandlers.delete(topic);
  }
  registerByteStreamHandler(topic, callback) {
    if (this.byteStreamHandlers.has(topic)) {
      throw new Error(`A byte stream handler for topic "${topic}" has already been set.`);
    }
    this.byteStreamHandlers.set(topic, callback);
  }
  unregisterByteStreamHandler(topic) {
    this.byteStreamHandlers.delete(topic);
  }
  retrieveParticipantByIdentity(identity) {
    var _a;
    if (((_a = this.localParticipant) == null ? void 0 : _a.identity) === identity) {
      return this.localParticipant;
    } else {
      return this.remoteParticipants.get(identity);
    }
  }
  requireParticipantByIdentity(identity) {
    var _a;
    if (((_a = this.localParticipant) == null ? void 0 : _a.identity) === identity) {
      return this.localParticipant;
    } else if (this.remoteParticipants.has(identity)) {
      return this.remoteParticipants.get(identity);
    } else {
      throw new TypeError(`participant ${identity} not found`);
    }
  }
  requireRemoteParticipant(identity) {
    const participant = this.remoteParticipants.get(identity);
    if (!participant) {
      throw new TypeError(`participant ${identity} not found`);
    }
    return participant;
  }
  requirePublicationOfParticipant(identity, trackSid) {
    const participant = this.requireParticipantByIdentity(identity);
    const publication = participant.trackPublications.get(trackSid);
    if (!publication) {
      throw new TypeError(`publication ${trackSid} not found`);
    }
    return { participant, publication };
  }
  requirePublicationOfRemoteParticipant(identity, trackSid) {
    const participant = this.requireRemoteParticipant(identity);
    const publication = participant.trackPublications.get(trackSid);
    if (!publication) {
      throw new TypeError(`publication ${trackSid} not found`);
    }
    return { participant, publication };
  }
  createRemoteParticipant(ownedInfo) {
    if (this.remoteParticipants.has(ownedInfo.info.identity)) {
      throw new Error("Participant already exists");
    }
    const participant = new import_participant.RemoteParticipant(ownedInfo);
    this.remoteParticipants.set(ownedInfo.info.identity, participant);
    return participant;
  }
  handleStreamHeader(streamHeader, participantIdentity) {
    if (streamHeader.contentHeader.case === "byteHeader") {
      const streamHandlerCallback = this.byteStreamHandlers.get(streamHeader.topic ?? "");
      if (!streamHandlerCallback) {
        import_log.log.debug("ignoring incoming byte stream due to no handler for topic", streamHeader.topic);
        return;
      }
      let streamController;
      const stream = new import_web.ReadableStream({
        start: (controller) => {
          streamController = controller;
          this.byteStreamControllers.set(streamHeader.streamId, {
            header: streamHeader,
            controller: streamController,
            startTime: Date.now()
          });
        }
      });
      const info = {
        streamId: streamHeader.streamId,
        name: streamHeader.contentHeader.value.name ?? "unknown",
        mimeType: streamHeader.mimeType,
        totalSize: streamHeader.totalLength ? Number(streamHeader.totalLength) : void 0,
        topic: streamHeader.topic,
        timestamp: (0, import_utils.bigIntToNumber)(streamHeader.timestamp),
        attributes: streamHeader.attributes
      };
      streamHandlerCallback(
        new import_stream_reader.ByteStreamReader(info, stream, (0, import_utils.bigIntToNumber)(streamHeader.totalLength)),
        { identity: participantIdentity }
      );
    } else if (streamHeader.contentHeader.case === "textHeader") {
      const streamHandlerCallback = this.textStreamHandlers.get(streamHeader.topic ?? "");
      if (!streamHandlerCallback) {
        import_log.log.debug("ignoring incoming text stream due to no handler for topic", streamHeader.topic);
        return;
      }
      let streamController;
      const stream = new import_web.ReadableStream({
        start: (controller) => {
          streamController = controller;
          this.textStreamControllers.set(streamHeader.streamId, {
            header: streamHeader,
            controller: streamController,
            startTime: Date.now()
          });
        }
      });
      const info = {
        streamId: streamHeader.streamId,
        mimeType: streamHeader.mimeType,
        totalSize: streamHeader.totalLength ? Number(streamHeader.totalLength) : void 0,
        topic: streamHeader.topic,
        timestamp: Number(streamHeader.timestamp),
        attributes: streamHeader.attributes
      };
      streamHandlerCallback(
        new import_stream_reader.TextStreamReader(info, stream, (0, import_utils.bigIntToNumber)(streamHeader.totalLength)),
        { identity: participantIdentity }
      );
    }
  }
  handleStreamChunk(chunk) {
    const fileBuffer = this.byteStreamControllers.get(chunk.streamId);
    if (fileBuffer) {
      if (chunk.content.length > 0) {
        fileBuffer.controller.enqueue(chunk);
      }
    }
    const textBuffer = this.textStreamControllers.get(chunk.streamId);
    if (textBuffer) {
      if (chunk.content.length > 0) {
        textBuffer.controller.enqueue(chunk);
      }
    }
  }
  handleStreamTrailer(trailer) {
    const streamId = trailer.streamId;
    const fileBuffer = this.byteStreamControllers.get(streamId);
    if (fileBuffer) {
      fileBuffer.controller.close();
      this.byteStreamControllers.delete(streamId);
    }
    const textBuffer = this.textStreamControllers.get(streamId);
    if (textBuffer) {
      textBuffer.controller.close();
      this.byteStreamControllers.delete(streamId);
    }
  }
}
class ConnectError extends Error {
  constructor(message) {
    super(message);
  }
}
var RoomEvent = /* @__PURE__ */ ((RoomEvent2) => {
  RoomEvent2["ParticipantConnected"] = "participantConnected";
  RoomEvent2["ParticipantDisconnected"] = "participantDisconnected";
  RoomEvent2["LocalTrackPublished"] = "localTrackPublished";
  RoomEvent2["LocalTrackUnpublished"] = "localTrackUnpublished";
  RoomEvent2["LocalTrackSubscribed"] = "localTrackSubscribed";
  RoomEvent2["TrackPublished"] = "trackPublished";
  RoomEvent2["TrackUnpublished"] = "trackUnpublished";
  RoomEvent2["TrackSubscribed"] = "trackSubscribed";
  RoomEvent2["TrackUnsubscribed"] = "trackUnsubscribed";
  RoomEvent2["TrackSubscriptionFailed"] = "trackSubscriptionFailed";
  RoomEvent2["TrackMuted"] = "trackMuted";
  RoomEvent2["TrackUnmuted"] = "trackUnmuted";
  RoomEvent2["ActiveSpeakersChanged"] = "activeSpeakersChanged";
  RoomEvent2["RoomMetadataChanged"] = "roomMetadataChanged";
  RoomEvent2["RoomSidChanged"] = "roomSidChanged";
  RoomEvent2["ParticipantMetadataChanged"] = "participantMetadataChanged";
  RoomEvent2["ParticipantNameChanged"] = "participantNameChanged";
  RoomEvent2["ParticipantAttributesChanged"] = "participantAttributesChanged";
  RoomEvent2["ConnectionQualityChanged"] = "connectionQualityChanged";
  RoomEvent2["DataReceived"] = "dataReceived";
  RoomEvent2["ChatMessage"] = "chatMessage";
  RoomEvent2["DtmfReceived"] = "dtmfReceived";
  RoomEvent2["EncryptionError"] = "encryptionError";
  RoomEvent2["ConnectionStateChanged"] = "connectionStateChanged";
  RoomEvent2["Connected"] = "connected";
  RoomEvent2["Disconnected"] = "disconnected";
  RoomEvent2["Reconnecting"] = "reconnecting";
  RoomEvent2["Reconnected"] = "reconnected";
  return RoomEvent2;
})(RoomEvent || {});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ConnectError,
  Room,
  RoomEvent,
  defaultRoomOptions,
  defaultRtcConfiguration
});
//# sourceMappingURL=room.cjs.map