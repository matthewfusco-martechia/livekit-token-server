import { ReadableStream } from 'node:stream/web';
import { DataStream_Chunk, DataStream_Header } from './proto/room_pb.js';

interface StreamController<T extends DataStream_Chunk> {
    header: DataStream_Header;
    controller: ReadableStreamDefaultController<T>;
    startTime: number;
    endTime?: number;
}
interface BaseStreamInfo {
    streamId: string;
    mimeType: string;
    topic: string;
    timestamp: number;
    /** total size in bytes for finite streams and undefined for streams of unknown size */
    totalSize?: number;
    attributes?: Record<string, string>;
}
type ByteStreamInfo = BaseStreamInfo & {
    name: string;
};
type TextStreamInfo = BaseStreamInfo;
interface DataStreamOptions {
    topic?: string;
    destinationIdentities?: Array<string>;
    attributes?: Record<string, string>;
    mimeType?: string;
}
interface TextStreamOptions extends DataStreamOptions {
    attachments?: [];
}
interface ByteStreamOptions extends DataStreamOptions {
    name?: string;
    onProgress?: (progress: number) => void;
}
type ByteStreamHandler = (reader: ByteStreamReader, participantInfo: {
    identity: string;
}) => void;
type TextStreamHandler = (reader: TextStreamReader, participantInfo: {
    identity: string;
}) => void;

declare abstract class BaseStreamReader<T extends BaseStreamInfo> {
    protected reader: ReadableStream<DataStream_Chunk>;
    protected totalByteSize?: number;
    protected _info: T;
    protected bytesReceived: number;
    get info(): T;
    constructor(info: T, stream: ReadableStream<DataStream_Chunk>, totalByteSize?: number);
    protected abstract handleChunkReceived(chunk: DataStream_Chunk): void;
    onProgress?: (progress: number | undefined) => void;
    abstract readAll(): Promise<string | Array<Uint8Array>>;
}
/**
 * A class to read chunks from a ReadableStream and provide them in a structured format.
 */
declare class ByteStreamReader extends BaseStreamReader<ByteStreamInfo> {
    protected handleChunkReceived(chunk: DataStream_Chunk): void;
    [Symbol.asyncIterator](): {
        next: () => Promise<IteratorResult<Uint8Array>>;
        return(): IteratorResult<Uint8Array>;
    };
    readAll(): Promise<Array<Uint8Array>>;
}
/**
 * A class to read chunks from a ReadableStream and provide them in a structured format.
 */
declare class TextStreamReader extends BaseStreamReader<TextStreamInfo> {
    private receivedChunks;
    /**
     * A TextStreamReader instance can be used as an AsyncIterator that returns the entire string
     * that has been received up to the current point in time.
     */
    constructor(info: TextStreamInfo, stream: ReadableStream<DataStream_Chunk>, totalChunkCount?: number);
    protected handleChunkReceived(chunk: DataStream_Chunk): void;
    /**
     * Async iterator implementation to allow usage of `for await...of` syntax.
     * Yields structured chunks from the stream.
     *
     */
    [Symbol.asyncIterator](): {
        next: () => Promise<IteratorResult<string>>;
        return(): IteratorResult<string>;
    };
    readAll(): Promise<string>;
}

export { ByteStreamReader as B, type DataStreamOptions as D, type StreamController as S, TextStreamReader as T, type BaseStreamInfo as a, type ByteStreamInfo as b, type TextStreamInfo as c, type TextStreamOptions as d, type ByteStreamOptions as e, type ByteStreamHandler as f, type TextStreamHandler as g };
