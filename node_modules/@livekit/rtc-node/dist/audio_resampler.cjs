"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var audio_resampler_exports = {};
__export(audio_resampler_exports, {
  AudioResampler: () => AudioResampler,
  AudioResamplerQuality: () => AudioResamplerQuality
});
module.exports = __toCommonJS(audio_resampler_exports);
var import_audio_frame = require("./audio_frame.cjs");
var import_ffi_client = require("./ffi_client.cjs");
var import_audio_frame_pb = require("./proto/audio_frame_pb.cjs");
var AudioResamplerQuality = ((AudioResamplerQuality2) => {
  AudioResamplerQuality2[AudioResamplerQuality2["QUICK"] = import_audio_frame_pb.SoxQualityRecipe.SOXR_QUALITY_QUICK] = "QUICK";
  AudioResamplerQuality2[AudioResamplerQuality2["LOW"] = import_audio_frame_pb.SoxQualityRecipe.SOXR_QUALITY_LOW] = "LOW";
  AudioResamplerQuality2[AudioResamplerQuality2["MEDIUM"] = import_audio_frame_pb.SoxQualityRecipe.SOXR_QUALITY_MEDIUM] = "MEDIUM";
  AudioResamplerQuality2[AudioResamplerQuality2["HIGH"] = import_audio_frame_pb.SoxQualityRecipe.SOXR_QUALITY_HIGH] = "HIGH";
  AudioResamplerQuality2[AudioResamplerQuality2["VERY_HIGH"] = import_audio_frame_pb.SoxQualityRecipe.SOXR_QUALITY_VERYHIGH] = "VERY_HIGH";
  return AudioResamplerQuality2;
})(AudioResamplerQuality || {});
class AudioResampler {
  #inputRate;
  #outputRate;
  #channels;
  #ffiHandle;
  /**
   * Initializes a new AudioResampler.
   *
   * @param inputRate - The sample rate of the input audio data (in Hz).
   * @param outputRate - The desired sample rate of the output audio data (in Hz).
   * @param channels - The number of audio channels (e.g., 1 for mono, 2 for stereo). Defaults to 1.
   * @param quality - The quality setting for the resampler. Defaults to
   * `AudioResamplerQuality.MEDIUM`.
   */
  constructor(inputRate, outputRate, channels = 1, quality = AudioResamplerQuality.MEDIUM) {
    this.#inputRate = inputRate;
    this.#outputRate = outputRate;
    this.#channels = channels;
    const req = new import_audio_frame_pb.NewSoxResamplerRequest({
      inputRate,
      outputRate,
      numChannels: channels,
      qualityRecipe: quality,
      inputDataType: import_audio_frame_pb.SoxResamplerDataType.SOXR_DATATYPE_INT16I,
      outputDataType: import_audio_frame_pb.SoxResamplerDataType.SOXR_DATATYPE_INT16I,
      flags: 0
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: {
        case: "newSoxResampler",
        value: req
      }
    });
    switch (res.message.case) {
      case "resampler":
        this.#ffiHandle = new import_ffi_client.FfiHandle(res.message.value.handle.id);
        break;
      case "error":
      default:
        throw new Error(res.message.value);
    }
  }
  /**
   * Push audio data into the resampler and retrieve any available resampled data.
   *
   * This method accepts audio data, resamples it according to the configured input and output rates,
   * and returns any resampled data that is available after processing the input.
   *
   * @param data - The audio frame to resample
   *
   * @returns A list of {@link AudioFrame} objects containing the resampled audio data. The list may
   * be empty if no output data is available yet.
   */
  push(data) {
    const req = new import_audio_frame_pb.PushSoxResamplerRequest({
      resamplerHandle: this.#ffiHandle.handle,
      dataPtr: data.protoInfo().dataPtr,
      size: data.data.byteLength
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: {
        case: "pushSoxResampler",
        value: req
      }
    });
    if (res.error) {
      throw new Error(res.error);
    }
    if (!res.outputPtr) {
      return [];
    }
    const outputData = import_ffi_client.FfiClient.instance.copyBuffer(res.outputPtr, res.size);
    return [
      new import_audio_frame.AudioFrame(
        new Int16Array(outputData.buffer),
        this.#outputRate,
        this.#channels,
        Math.trunc(outputData.length / this.#channels / 2)
      )
    ];
  }
  /**
   * Flush any remaining audio data through the resampler and retrieve the resampled data.
   *
   * @remarks
   * This method should be called when no more input data will be provided to ensure that all
   * internal buffers are processed and all resampled data is output.
   */
  flush() {
    const req = new import_audio_frame_pb.FlushSoxResamplerRequest({
      resamplerHandle: this.#ffiHandle.handle
    });
    const res = import_ffi_client.FfiClient.instance.request({
      message: {
        case: "flushSoxResampler",
        value: req
      }
    });
    if (res.error) {
      throw new Error(res.error);
    }
    if (!res.outputPtr) {
      return [];
    }
    const outputData = import_ffi_client.FfiClient.instance.copyBuffer(res.outputPtr, res.size);
    return [
      new import_audio_frame.AudioFrame(
        new Int16Array(outputData.buffer),
        this.#outputRate,
        this.#channels,
        Math.trunc(outputData.length / this.#channels / 2)
      )
    ];
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AudioResampler,
  AudioResamplerQuality
});
//# sourceMappingURL=audio_resampler.cjs.map