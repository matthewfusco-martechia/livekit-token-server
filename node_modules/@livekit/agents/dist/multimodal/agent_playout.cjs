"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var agent_playout_exports = {};
__export(agent_playout_exports, {
  AgentPlayout: () => AgentPlayout,
  PlayoutHandle: () => PlayoutHandle,
  proto: () => proto
});
module.exports = __toCommonJS(agent_playout_exports);
var import_node_events = require("node:events");
var import_audio = require("../audio.cjs");
var import_utils = require("../utils.cjs");
const proto = {};
class PlayoutHandle extends import_node_events.EventEmitter {
  #audioSource;
  #sampleRate;
  #itemId;
  #contentIndex;
  /** @internal */
  synchronizer;
  /** @internal */
  doneFut;
  /** @internal */
  intFut;
  /** @internal */
  #interrupted;
  /** @internal */
  pushedDuration;
  /** @internal */
  totalPlayedTime;
  // Set when playout is done
  constructor(audioSource, sampleRate, itemId, contentIndex, synchronizer) {
    super();
    this.#audioSource = audioSource;
    this.#sampleRate = sampleRate;
    this.#itemId = itemId;
    this.#contentIndex = contentIndex;
    this.synchronizer = synchronizer;
    this.doneFut = new import_utils.Future();
    this.intFut = new import_utils.Future();
    this.#interrupted = false;
    this.pushedDuration = 0;
    this.totalPlayedTime = void 0;
  }
  get itemId() {
    return this.#itemId;
  }
  get audioSamples() {
    if (this.totalPlayedTime !== void 0) {
      return Math.floor(this.totalPlayedTime * this.#sampleRate);
    }
    return Math.floor(
      (this.pushedDuration - this.#audioSource.queuedDuration) * (this.#sampleRate / 1e3)
    );
  }
  get textChars() {
    return this.synchronizer.playedText.length;
  }
  get contentIndex() {
    return this.#contentIndex;
  }
  get interrupted() {
    return this.#interrupted;
  }
  get done() {
    return this.doneFut.done || this.#interrupted;
  }
  interrupt() {
    if (this.doneFut.done) return;
    this.intFut.resolve();
    this.#interrupted = true;
  }
}
class AgentPlayout extends import_node_events.EventEmitter {
  #audioSource;
  #playoutTask;
  #sampleRate;
  #numChannels;
  #inFrameSize;
  #outFrameSize;
  constructor(audioSource, sampleRate, numChannels, inFrameSize, outFrameSize) {
    super();
    this.#audioSource = audioSource;
    this.#playoutTask = null;
    this.#sampleRate = sampleRate;
    this.#numChannels = numChannels;
    this.#inFrameSize = inFrameSize;
    this.#outFrameSize = outFrameSize;
  }
  play(itemId, contentIndex, synchronizer, textStream, audioStream) {
    const handle = new PlayoutHandle(
      this.#audioSource,
      this.#sampleRate,
      itemId,
      contentIndex,
      synchronizer
    );
    this.#playoutTask = this.#makePlayoutTask(this.#playoutTask, handle, textStream, audioStream);
    return handle;
  }
  #makePlayoutTask(oldTask, handle, textStream, audioStream) {
    return new import_utils.CancellablePromise((resolve, reject, onCancel) => {
      let cancelled = false;
      onCancel(() => {
        cancelled = true;
      });
      (async () => {
        try {
          if (oldTask) {
            await (0, import_utils.gracefullyCancel)(oldTask);
          }
          let firstFrame = true;
          const readText = () => new import_utils.CancellablePromise((resolveText, rejectText, onCancelText) => {
            let cancelledText = false;
            onCancelText(() => {
              cancelledText = true;
            });
            (async () => {
              try {
                for await (const text of textStream) {
                  if (cancelledText || cancelled) {
                    break;
                  }
                  handle.synchronizer.pushText(text);
                }
                handle.synchronizer.markTextSegmentEnd();
                resolveText();
              } catch (error) {
                rejectText(error);
              }
            })();
          });
          const capture = () => new import_utils.CancellablePromise((resolveCapture, rejectCapture, onCancelCapture) => {
            let cancelledCapture = false;
            onCancelCapture(() => {
              cancelledCapture = true;
            });
            (async () => {
              try {
                const samplesPerChannel = this.#outFrameSize;
                const bstream = new import_audio.AudioByteStream(
                  this.#sampleRate,
                  this.#numChannels,
                  samplesPerChannel
                );
                for await (const frame of audioStream) {
                  if (cancelledCapture || cancelled) {
                    break;
                  }
                  if (firstFrame) {
                    handle.synchronizer.segmentPlayoutStarted();
                    this.emit("playout_started");
                    firstFrame = false;
                  }
                  handle.synchronizer.pushAudio(frame);
                  for (const f of bstream.write(frame.data.buffer)) {
                    handle.pushedDuration += f.samplesPerChannel / f.sampleRate * 1e3;
                    await this.#audioSource.captureFrame(f);
                  }
                }
                if (!cancelledCapture && !cancelled) {
                  for (const f of bstream.flush()) {
                    handle.pushedDuration += f.samplesPerChannel / f.sampleRate * 1e3;
                    await this.#audioSource.captureFrame(f);
                  }
                  handle.synchronizer.markAudioSegmentEnd();
                  await this.#audioSource.waitForPlayout();
                }
                resolveCapture();
              } catch (error) {
                rejectCapture(error);
              }
            })();
          });
          const readTextTask = readText();
          const captureTask = capture();
          try {
            await Promise.race([captureTask, handle.intFut.await]);
          } finally {
            if (!captureTask.isCancelled) {
              await (0, import_utils.gracefullyCancel)(captureTask);
            }
            handle.totalPlayedTime = handle.pushedDuration - this.#audioSource.queuedDuration;
            if (handle.interrupted || captureTask.error) {
              await handle.synchronizer.close(true);
              this.#audioSource.clearQueue();
            }
            if (!readTextTask.isCancelled) {
              await (0, import_utils.gracefullyCancel)(readTextTask);
            }
            if (!firstFrame) {
              this.emit("playout_stopped", handle.interrupted);
            }
            handle.doneFut.resolve();
            await handle.synchronizer.close(false);
          }
          resolve();
        } catch (error) {
          reject(error);
        }
      })();
    });
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AgentPlayout,
  PlayoutHandle,
  proto
});
//# sourceMappingURL=agent_playout.cjs.map