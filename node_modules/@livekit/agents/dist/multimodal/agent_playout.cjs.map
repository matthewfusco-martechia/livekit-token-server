{"version":3,"sources":["../../src/multimodal/agent_playout.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { AudioFrame } from '@livekit/rtc-node';\nimport { type AudioSource } from '@livekit/rtc-node';\nimport { EventEmitter } from 'node:events';\nimport { AudioByteStream } from '../audio.js';\nimport type { TextAudioSynchronizer } from '../transcription.js';\nimport { type AsyncIterableQueue, CancellablePromise, Future, gracefullyCancel } from '../utils.js';\n\nexport const proto = {};\n\nexport class PlayoutHandle extends EventEmitter {\n  #audioSource: AudioSource;\n  #sampleRate: number;\n  #itemId: string;\n  #contentIndex: number;\n  /** @internal */\n  synchronizer: TextAudioSynchronizer;\n  /** @internal */\n  doneFut: Future;\n  /** @internal */\n  intFut: Future;\n  /** @internal */\n  #interrupted: boolean;\n  /** @internal */\n  pushedDuration: number;\n  /** @internal */\n  totalPlayedTime: number | undefined; // Set when playout is done\n\n  constructor(\n    audioSource: AudioSource,\n    sampleRate: number,\n    itemId: string,\n    contentIndex: number,\n    synchronizer: TextAudioSynchronizer,\n  ) {\n    super();\n    this.#audioSource = audioSource;\n    this.#sampleRate = sampleRate;\n    this.#itemId = itemId;\n    this.#contentIndex = contentIndex;\n    this.synchronizer = synchronizer;\n    this.doneFut = new Future();\n    this.intFut = new Future();\n    this.#interrupted = false;\n    this.pushedDuration = 0;\n    this.totalPlayedTime = undefined;\n  }\n\n  get itemId(): string {\n    return this.#itemId;\n  }\n\n  get audioSamples(): number {\n    if (this.totalPlayedTime !== undefined) {\n      return Math.floor(this.totalPlayedTime * this.#sampleRate);\n    }\n\n    return Math.floor(\n      (this.pushedDuration - this.#audioSource.queuedDuration) * (this.#sampleRate / 1000),\n    );\n  }\n\n  get textChars(): number {\n    return this.synchronizer.playedText.length;\n  }\n\n  get contentIndex(): number {\n    return this.#contentIndex;\n  }\n\n  get interrupted(): boolean {\n    return this.#interrupted;\n  }\n\n  get done(): boolean {\n    return this.doneFut.done || this.#interrupted;\n  }\n\n  interrupt() {\n    if (this.doneFut.done) return;\n    this.intFut.resolve();\n    this.#interrupted = true;\n  }\n}\n\nexport class AgentPlayout extends EventEmitter {\n  #audioSource: AudioSource;\n  #playoutTask: CancellablePromise<void> | null;\n  #sampleRate: number;\n  #numChannels: number;\n  #inFrameSize: number;\n  #outFrameSize: number;\n  constructor(\n    audioSource: AudioSource,\n    sampleRate: number,\n    numChannels: number,\n    inFrameSize: number,\n    outFrameSize: number,\n  ) {\n    super();\n    this.#audioSource = audioSource;\n    this.#playoutTask = null;\n    this.#sampleRate = sampleRate;\n    this.#numChannels = numChannels;\n    this.#inFrameSize = inFrameSize;\n    this.#outFrameSize = outFrameSize;\n  }\n\n  play(\n    itemId: string,\n    contentIndex: number,\n    synchronizer: TextAudioSynchronizer,\n    textStream: AsyncIterableQueue<string>,\n    audioStream: AsyncIterableQueue<AudioFrame>,\n  ): PlayoutHandle {\n    const handle = new PlayoutHandle(\n      this.#audioSource,\n      this.#sampleRate,\n      itemId,\n      contentIndex,\n      synchronizer,\n    );\n    this.#playoutTask = this.#makePlayoutTask(this.#playoutTask, handle, textStream, audioStream);\n    return handle;\n  }\n\n  #makePlayoutTask(\n    oldTask: CancellablePromise<void> | null,\n    handle: PlayoutHandle,\n    textStream: AsyncIterableQueue<string>,\n    audioStream: AsyncIterableQueue<AudioFrame>,\n  ): CancellablePromise<void> {\n    return new CancellablePromise<void>((resolve, reject, onCancel) => {\n      let cancelled = false;\n      onCancel(() => {\n        cancelled = true;\n      });\n\n      (async () => {\n        try {\n          if (oldTask) {\n            await gracefullyCancel(oldTask);\n          }\n\n          let firstFrame = true;\n\n          const readText = () =>\n            new CancellablePromise<void>((resolveText, rejectText, onCancelText) => {\n              let cancelledText = false;\n              onCancelText(() => {\n                cancelledText = true;\n              });\n\n              (async () => {\n                try {\n                  for await (const text of textStream) {\n                    if (cancelledText || cancelled) {\n                      break;\n                    }\n                    handle.synchronizer.pushText(text);\n                  }\n                  handle.synchronizer.markTextSegmentEnd();\n                  resolveText();\n                } catch (error) {\n                  rejectText(error);\n                }\n              })();\n            });\n\n          const capture = () =>\n            new CancellablePromise<void>((resolveCapture, rejectCapture, onCancelCapture) => {\n              let cancelledCapture = false;\n              onCancelCapture(() => {\n                cancelledCapture = true;\n              });\n\n              (async () => {\n                try {\n                  const samplesPerChannel = this.#outFrameSize;\n                  const bstream = new AudioByteStream(\n                    this.#sampleRate,\n                    this.#numChannels,\n                    samplesPerChannel,\n                  );\n\n                  for await (const frame of audioStream) {\n                    if (cancelledCapture || cancelled) {\n                      break;\n                    }\n                    if (firstFrame) {\n                      handle.synchronizer.segmentPlayoutStarted();\n                      this.emit('playout_started');\n                      firstFrame = false;\n                    }\n\n                    handle.synchronizer.pushAudio(frame);\n\n                    for (const f of bstream.write(frame.data.buffer)) {\n                      handle.pushedDuration += (f.samplesPerChannel / f.sampleRate) * 1000;\n                      await this.#audioSource.captureFrame(f);\n                    }\n                  }\n\n                  if (!cancelledCapture && !cancelled) {\n                    for (const f of bstream.flush()) {\n                      handle.pushedDuration += (f.samplesPerChannel / f.sampleRate) * 1000;\n                      await this.#audioSource.captureFrame(f);\n                    }\n\n                    handle.synchronizer.markAudioSegmentEnd();\n\n                    await this.#audioSource.waitForPlayout();\n                  }\n\n                  resolveCapture();\n                } catch (error) {\n                  rejectCapture(error);\n                }\n              })();\n            });\n\n          const readTextTask = readText();\n          const captureTask = capture();\n\n          try {\n            await Promise.race([captureTask, handle.intFut.await]);\n          } finally {\n            if (!captureTask.isCancelled) {\n              await gracefullyCancel(captureTask);\n            }\n\n            handle.totalPlayedTime = handle.pushedDuration - this.#audioSource.queuedDuration;\n\n            if (handle.interrupted || captureTask.error) {\n              await handle.synchronizer.close(true);\n              this.#audioSource.clearQueue(); // make sure to remove any queued frames\n            }\n\n            if (!readTextTask.isCancelled) {\n              await gracefullyCancel(readTextTask);\n            }\n\n            if (!firstFrame) {\n              this.emit('playout_stopped', handle.interrupted);\n            }\n\n            handle.doneFut.resolve();\n            await handle.synchronizer.close(false);\n          }\n\n          resolve();\n        } catch (error) {\n          reject(error);\n        }\n      })();\n    });\n  }\n}\n"],"mappings":"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","names":[]}