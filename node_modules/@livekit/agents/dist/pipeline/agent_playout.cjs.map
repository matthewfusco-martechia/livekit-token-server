{"version":3,"sources":["../../src/pipeline/agent_playout.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { AudioFrame, AudioSource } from '@livekit/rtc-node';\nimport type { TypedEventEmitter as TypedEmitter } from '@livekit/typed-emitter';\nimport EventEmitter from 'node:events';\nimport { log } from '../log.js';\nimport type { TextAudioSynchronizer } from '../transcription.js';\nimport { CancellablePromise, Future, gracefullyCancel } from '../utils.js';\nimport { SynthesisHandle } from './agent_output.js';\n\nexport enum AgentPlayoutEvent {\n  PLAYOUT_STARTED,\n  PLAYOUT_STOPPED,\n}\n\nexport type AgentPlayoutCallbacks = {\n  [AgentPlayoutEvent.PLAYOUT_STARTED]: () => void;\n  [AgentPlayoutEvent.PLAYOUT_STOPPED]: (interrupt: boolean) => void;\n};\n\nexport class PlayoutHandle {\n  #speechId: string;\n  #audioSource: AudioSource;\n  playoutSource: AsyncIterable<AudioFrame | typeof SynthesisHandle.FLUSH_SENTINEL>;\n  totalPlayedTime?: number;\n  synchronizer: TextAudioSynchronizer;\n  #interrupted = false;\n  pushedDuration = 0;\n  intFut = new Future();\n  doneFut = new Future();\n\n  constructor(\n    speechId: string,\n    audioSource: AudioSource,\n    playoutSource: AsyncIterable<AudioFrame | typeof SynthesisHandle.FLUSH_SENTINEL>,\n    synchronizer: TextAudioSynchronizer,\n  ) {\n    this.#speechId = speechId;\n    this.#audioSource = audioSource;\n    this.playoutSource = playoutSource;\n    this.synchronizer = synchronizer;\n  }\n\n  get speechId(): string {\n    return this.#speechId;\n  }\n\n  get interrupted(): boolean {\n    return this.#interrupted;\n  }\n\n  get timePlayed(): number {\n    return this.totalPlayedTime || this.pushedDuration - this.#audioSource.queuedDuration;\n  }\n\n  get done(): boolean {\n    return this.doneFut.done || this.#interrupted;\n  }\n\n  interrupt() {\n    if (this.done) {\n      return;\n    }\n\n    this.intFut.resolve();\n    this.#interrupted = true;\n  }\n\n  join(): Future {\n    return this.doneFut;\n  }\n}\n\nexport class AgentPlayout extends (EventEmitter as new () => TypedEmitter<AgentPlayoutCallbacks>) {\n  #closed = false;\n  #audioSource: AudioSource;\n  #targetVolume = 1;\n  #playoutTask?: CancellablePromise<void>;\n  #logger = log();\n\n  constructor(audioSource: AudioSource) {\n    super();\n    this.#audioSource = audioSource;\n  }\n\n  get targetVolume(): number {\n    return this.#targetVolume;\n  }\n\n  set targetVolume(vol: number) {\n    this.#targetVolume = vol;\n  }\n\n  play(\n    speechId: string,\n    playoutSource: AsyncIterable<AudioFrame | typeof SynthesisHandle.FLUSH_SENTINEL>,\n    synchronizer: TextAudioSynchronizer,\n  ): PlayoutHandle {\n    if (this.#closed) {\n      throw new Error('source closed');\n    }\n\n    const handle = new PlayoutHandle(speechId, this.#audioSource, playoutSource, synchronizer);\n\n    this.#playoutTask = this.#playout(handle, this.#playoutTask);\n    return handle;\n  }\n\n  #playout(handle: PlayoutHandle, oldTask?: CancellablePromise<void>): CancellablePromise<void> {\n    return new CancellablePromise(async (resolve, _, onCancel) => {\n      const cancel = () => {\n        captureTask.cancel();\n        handle.totalPlayedTime = handle.pushedDuration - this.#audioSource.queuedDuration;\n\n        if (handle.interrupted || captureTask.error) {\n          handle.synchronizer.close(true);\n          this.#audioSource.clearQueue(); // make sure to remove any queued frames\n        }\n\n        if (!firstFrame) {\n          this.emit(AgentPlayoutEvent.PLAYOUT_STOPPED, handle.interrupted);\n        }\n\n        handle.doneFut.resolve();\n\n        this.#logger\n          .child({ speechId: handle.speechId, interrupted: handle.interrupted })\n          .debug('playout finished');\n      };\n\n      onCancel(() => {\n        cancel();\n      });\n\n      if (oldTask) {\n        await gracefullyCancel(oldTask);\n      }\n\n      if (this.#audioSource.queuedDuration > 0) {\n        // this should not happen, but log it just in case\n        this.#logger\n          .child({ speechId: handle.speechId, queuedDuration: this.#audioSource.queuedDuration })\n          .warn('new playout while the source is still playing');\n      }\n\n      let firstFrame = true;\n\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const captureTask = new CancellablePromise<void>(async (resolve, _, onCancel) => {\n        let cancelled = false;\n        onCancel(() => {\n          cancelled = true;\n        });\n\n        for await (const frame of handle.playoutSource) {\n          if (cancelled || frame === SynthesisHandle.FLUSH_SENTINEL) {\n            break;\n          }\n          if (firstFrame) {\n            this.#logger\n              .child({ speechId: handle.speechId })\n              .debug('started playing the first time');\n            this.emit(AgentPlayoutEvent.PLAYOUT_STARTED);\n            handle.synchronizer.segmentPlayoutStarted();\n            firstFrame = false;\n          }\n          handle.pushedDuration += (frame.samplesPerChannel / frame.sampleRate) * 1000;\n          handle.synchronizer.pushAudio(frame);\n          await this.#audioSource.captureFrame(frame);\n          await this.#audioSource.waitForPlayout();\n        }\n\n        // XXX(nbsp): line 161 waits instead of this. this is not the case on python agents,\n        //            but for some reason too many TTS frames can gunk up the buffer and lead to\n        //            FFI errors. this works 🤷‍♀️\n        // if (this.#audioSource.queuedDuration > 0) {\n        //   await this.#audioSource.waitForPlayout();\n        // }\n\n        handle.synchronizer.close(false);\n        resolve();\n      });\n\n      try {\n        await Promise.any([captureTask, handle.intFut.await]);\n      } finally {\n        cancel();\n        resolve();\n      }\n    });\n  }\n\n  async close() {\n    this.#closed = true;\n    await this.#playoutTask;\n  }\n}\n"],"mappings":"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","names":["AgentPlayoutEvent","EventEmitter","resolve","_","onCancel"]}