{"version":3,"sources":["../../src/pipeline/human_input.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type {\n  RemoteAudioTrack,\n  RemoteParticipant,\n  RemoteTrackPublication,\n  Room,\n} from '@livekit/rtc-node';\nimport { AudioStream, RoomEvent, TrackSource } from '@livekit/rtc-node';\nimport type { TypedEventEmitter as TypedEmitter } from '@livekit/typed-emitter';\nimport { EventEmitter } from 'node:events';\nimport { log } from '../log.js';\nimport type { STT, SpeechEvent } from '../stt/stt.js';\nimport { SpeechEventType } from '../stt/stt.js';\nimport { CancellablePromise, gracefullyCancel } from '../utils.js';\nimport type { VAD, VADEvent } from '../vad.js';\nimport { VADEventType } from '../vad.js';\n\nexport enum HumanInputEvent {\n  START_OF_SPEECH,\n  VAD_INFERENCE_DONE,\n  END_OF_SPEECH,\n  FINAL_TRANSCRIPT,\n  INTERIM_TRANSCRIPT,\n}\n\nexport type HumanInputCallbacks = {\n  [HumanInputEvent.START_OF_SPEECH]: (event: VADEvent) => void;\n  [HumanInputEvent.VAD_INFERENCE_DONE]: (event: VADEvent) => void;\n  [HumanInputEvent.END_OF_SPEECH]: (event: VADEvent) => void;\n  [HumanInputEvent.FINAL_TRANSCRIPT]: (event: SpeechEvent) => void;\n  [HumanInputEvent.INTERIM_TRANSCRIPT]: (event: SpeechEvent) => void;\n};\n\nexport class HumanInput extends (EventEmitter as new () => TypedEmitter<HumanInputCallbacks>) {\n  #closed = false;\n  #room: Room;\n  #vad: VAD;\n  #stt: STT;\n  #participant: RemoteParticipant;\n  #subscribedTrack?: RemoteAudioTrack;\n  #recognizeTask?: CancellablePromise<void>;\n  #speaking = false;\n  #speechProbability = 0;\n  #logger = log();\n\n  constructor(room: Room, vad: VAD, stt: STT, participant: RemoteParticipant) {\n    super();\n    this.#room = room;\n    this.#vad = vad;\n    this.#stt = stt;\n    this.#participant = participant;\n\n    this.#room.on(RoomEvent.TrackPublished, this.#subscribeToMicrophone.bind(this));\n    this.#room.on(RoomEvent.TrackSubscribed, this.#subscribeToMicrophone.bind(this));\n    this.#subscribeToMicrophone();\n  }\n\n  get participant(): RemoteParticipant {\n    return this.#participant;\n  }\n\n  get subscribedTrack(): RemoteAudioTrack | undefined {\n    return this.#subscribedTrack;\n  }\n\n  #subscribeToMicrophone(): void {\n    if (!this.#participant) {\n      this.#logger.error('Participant is not set');\n      return;\n    }\n\n    let microphonePublication: RemoteTrackPublication | undefined = undefined;\n    for (const publication of this.#participant.trackPublications.values()) {\n      if (publication.source === TrackSource.SOURCE_MICROPHONE) {\n        microphonePublication = publication;\n        break;\n      }\n    }\n    if (!microphonePublication) {\n      return;\n    }\n\n    if (!microphonePublication.subscribed) {\n      microphonePublication.setSubscribed(true);\n    }\n\n    const track = microphonePublication.track;\n    if (track && track !== this.#subscribedTrack) {\n      this.#subscribedTrack = track;\n      if (this.#recognizeTask) {\n        this.#recognizeTask.cancel();\n      }\n\n      const audioStream = new AudioStream(track, 16000);\n\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      this.#recognizeTask = new CancellablePromise(async (resolve, _, onCancel) => {\n        let cancelled = false;\n        onCancel(() => {\n          cancelled = true;\n        });\n\n        const sttStream = this.#stt.stream();\n        const vadStream = this.#vad.stream();\n\n        const audioStreamCo = async () => {\n          for await (const ev of audioStream) {\n            if (cancelled) return;\n            sttStream.pushFrame(ev);\n            vadStream.pushFrame(ev);\n          }\n        };\n\n        const vadStreamCo = async () => {\n          for await (const ev of vadStream) {\n            if (cancelled) return;\n            switch (ev.type) {\n              case VADEventType.START_OF_SPEECH:\n                this.#speaking = true;\n                this.emit(HumanInputEvent.START_OF_SPEECH, ev);\n                break;\n              case VADEventType.INFERENCE_DONE:\n                this.#speechProbability = ev.probability;\n                this.emit(HumanInputEvent.VAD_INFERENCE_DONE, ev);\n                break;\n              case VADEventType.END_OF_SPEECH:\n                this.#speaking = false;\n                this.emit(HumanInputEvent.END_OF_SPEECH, ev);\n                break;\n            }\n          }\n        };\n\n        const sttStreamCo = async () => {\n          for await (const ev of sttStream) {\n            if (cancelled) return;\n            if (ev.type === SpeechEventType.FINAL_TRANSCRIPT) {\n              this.emit(HumanInputEvent.FINAL_TRANSCRIPT, ev);\n            } else if (ev.type == SpeechEventType.INTERIM_TRANSCRIPT) {\n              this.emit(HumanInputEvent.INTERIM_TRANSCRIPT, ev);\n            }\n          }\n        };\n\n        await Promise.all([audioStreamCo(), vadStreamCo(), sttStreamCo()]);\n        sttStream.close();\n        vadStream.close();\n        resolve();\n      });\n    }\n  }\n\n  get speaking(): boolean {\n    return this.#speaking;\n  }\n\n  get speakingProbability(): number {\n    return this.#speechProbability;\n  }\n\n  async close() {\n    if (this.#closed) {\n      throw new Error('HumanInput already closed');\n    }\n    this.#closed = true;\n    this.#room.removeAllListeners();\n    this.#speaking = false;\n    if (this.#recognizeTask) {\n      await gracefullyCancel(this.#recognizeTask);\n    }\n  }\n}\n"],"mappings":"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","names":["HumanInputEvent"]}