import { AudioStream, RoomEvent, TrackSource } from "@livekit/rtc-node";
import { EventEmitter } from "node:events";
import { log } from "../log.js";
import { SpeechEventType } from "../stt/stt.js";
import { CancellablePromise, gracefullyCancel } from "../utils.js";
import { VADEventType } from "../vad.js";
var HumanInputEvent = /* @__PURE__ */ ((HumanInputEvent2) => {
  HumanInputEvent2[HumanInputEvent2["START_OF_SPEECH"] = 0] = "START_OF_SPEECH";
  HumanInputEvent2[HumanInputEvent2["VAD_INFERENCE_DONE"] = 1] = "VAD_INFERENCE_DONE";
  HumanInputEvent2[HumanInputEvent2["END_OF_SPEECH"] = 2] = "END_OF_SPEECH";
  HumanInputEvent2[HumanInputEvent2["FINAL_TRANSCRIPT"] = 3] = "FINAL_TRANSCRIPT";
  HumanInputEvent2[HumanInputEvent2["INTERIM_TRANSCRIPT"] = 4] = "INTERIM_TRANSCRIPT";
  return HumanInputEvent2;
})(HumanInputEvent || {});
class HumanInput extends EventEmitter {
  #closed = false;
  #room;
  #vad;
  #stt;
  #participant;
  #subscribedTrack;
  #recognizeTask;
  #speaking = false;
  #speechProbability = 0;
  #logger = log();
  constructor(room, vad, stt, participant) {
    super();
    this.#room = room;
    this.#vad = vad;
    this.#stt = stt;
    this.#participant = participant;
    this.#room.on(RoomEvent.TrackPublished, this.#subscribeToMicrophone.bind(this));
    this.#room.on(RoomEvent.TrackSubscribed, this.#subscribeToMicrophone.bind(this));
    this.#subscribeToMicrophone();
  }
  get participant() {
    return this.#participant;
  }
  get subscribedTrack() {
    return this.#subscribedTrack;
  }
  #subscribeToMicrophone() {
    if (!this.#participant) {
      this.#logger.error("Participant is not set");
      return;
    }
    let microphonePublication = void 0;
    for (const publication of this.#participant.trackPublications.values()) {
      if (publication.source === TrackSource.SOURCE_MICROPHONE) {
        microphonePublication = publication;
        break;
      }
    }
    if (!microphonePublication) {
      return;
    }
    if (!microphonePublication.subscribed) {
      microphonePublication.setSubscribed(true);
    }
    const track = microphonePublication.track;
    if (track && track !== this.#subscribedTrack) {
      this.#subscribedTrack = track;
      if (this.#recognizeTask) {
        this.#recognizeTask.cancel();
      }
      const audioStream = new AudioStream(track, 16e3);
      this.#recognizeTask = new CancellablePromise(async (resolve, _, onCancel) => {
        let cancelled = false;
        onCancel(() => {
          cancelled = true;
        });
        const sttStream = this.#stt.stream();
        const vadStream = this.#vad.stream();
        const audioStreamCo = async () => {
          for await (const ev of audioStream) {
            if (cancelled) return;
            sttStream.pushFrame(ev);
            vadStream.pushFrame(ev);
          }
        };
        const vadStreamCo = async () => {
          for await (const ev of vadStream) {
            if (cancelled) return;
            switch (ev.type) {
              case VADEventType.START_OF_SPEECH:
                this.#speaking = true;
                this.emit(0 /* START_OF_SPEECH */, ev);
                break;
              case VADEventType.INFERENCE_DONE:
                this.#speechProbability = ev.probability;
                this.emit(1 /* VAD_INFERENCE_DONE */, ev);
                break;
              case VADEventType.END_OF_SPEECH:
                this.#speaking = false;
                this.emit(2 /* END_OF_SPEECH */, ev);
                break;
            }
          }
        };
        const sttStreamCo = async () => {
          for await (const ev of sttStream) {
            if (cancelled) return;
            if (ev.type === SpeechEventType.FINAL_TRANSCRIPT) {
              this.emit(3 /* FINAL_TRANSCRIPT */, ev);
            } else if (ev.type == SpeechEventType.INTERIM_TRANSCRIPT) {
              this.emit(4 /* INTERIM_TRANSCRIPT */, ev);
            }
          }
        };
        await Promise.all([audioStreamCo(), vadStreamCo(), sttStreamCo()]);
        sttStream.close();
        vadStream.close();
        resolve();
      });
    }
  }
  get speaking() {
    return this.#speaking;
  }
  get speakingProbability() {
    return this.#speechProbability;
  }
  async close() {
    if (this.#closed) {
      throw new Error("HumanInput already closed");
    }
    this.#closed = true;
    this.#room.removeAllListeners();
    this.#speaking = false;
    if (this.#recognizeTask) {
      await gracefullyCancel(this.#recognizeTask);
    }
  }
}
export {
  HumanInput,
  HumanInputEvent
};
//# sourceMappingURL=human_input.js.map