import EventEmitter from "node:events";
import { log } from "../log.js";
import { CancellablePromise, Future, gracefullyCancel } from "../utils.js";
import { SynthesisHandle } from "./agent_output.js";
var AgentPlayoutEvent = /* @__PURE__ */ ((AgentPlayoutEvent2) => {
  AgentPlayoutEvent2[AgentPlayoutEvent2["PLAYOUT_STARTED"] = 0] = "PLAYOUT_STARTED";
  AgentPlayoutEvent2[AgentPlayoutEvent2["PLAYOUT_STOPPED"] = 1] = "PLAYOUT_STOPPED";
  return AgentPlayoutEvent2;
})(AgentPlayoutEvent || {});
class PlayoutHandle {
  #speechId;
  #audioSource;
  playoutSource;
  totalPlayedTime;
  synchronizer;
  #interrupted = false;
  pushedDuration = 0;
  intFut = new Future();
  doneFut = new Future();
  constructor(speechId, audioSource, playoutSource, synchronizer) {
    this.#speechId = speechId;
    this.#audioSource = audioSource;
    this.playoutSource = playoutSource;
    this.synchronizer = synchronizer;
  }
  get speechId() {
    return this.#speechId;
  }
  get interrupted() {
    return this.#interrupted;
  }
  get timePlayed() {
    return this.totalPlayedTime || this.pushedDuration - this.#audioSource.queuedDuration;
  }
  get done() {
    return this.doneFut.done || this.#interrupted;
  }
  interrupt() {
    if (this.done) {
      return;
    }
    this.intFut.resolve();
    this.#interrupted = true;
  }
  join() {
    return this.doneFut;
  }
}
class AgentPlayout extends EventEmitter {
  #closed = false;
  #audioSource;
  #targetVolume = 1;
  #playoutTask;
  #logger = log();
  constructor(audioSource) {
    super();
    this.#audioSource = audioSource;
  }
  get targetVolume() {
    return this.#targetVolume;
  }
  set targetVolume(vol) {
    this.#targetVolume = vol;
  }
  play(speechId, playoutSource, synchronizer) {
    if (this.#closed) {
      throw new Error("source closed");
    }
    const handle = new PlayoutHandle(speechId, this.#audioSource, playoutSource, synchronizer);
    this.#playoutTask = this.#playout(handle, this.#playoutTask);
    return handle;
  }
  #playout(handle, oldTask) {
    return new CancellablePromise(async (resolve, _, onCancel) => {
      const cancel = () => {
        captureTask.cancel();
        handle.totalPlayedTime = handle.pushedDuration - this.#audioSource.queuedDuration;
        if (handle.interrupted || captureTask.error) {
          handle.synchronizer.close(true);
          this.#audioSource.clearQueue();
        }
        if (!firstFrame) {
          this.emit(1 /* PLAYOUT_STOPPED */, handle.interrupted);
        }
        handle.doneFut.resolve();
        this.#logger.child({ speechId: handle.speechId, interrupted: handle.interrupted }).debug("playout finished");
      };
      onCancel(() => {
        cancel();
      });
      if (oldTask) {
        await gracefullyCancel(oldTask);
      }
      if (this.#audioSource.queuedDuration > 0) {
        this.#logger.child({ speechId: handle.speechId, queuedDuration: this.#audioSource.queuedDuration }).warn("new playout while the source is still playing");
      }
      let firstFrame = true;
      const captureTask = new CancellablePromise(async (resolve2, _2, onCancel2) => {
        let cancelled = false;
        onCancel2(() => {
          cancelled = true;
        });
        for await (const frame of handle.playoutSource) {
          if (cancelled || frame === SynthesisHandle.FLUSH_SENTINEL) {
            break;
          }
          if (firstFrame) {
            this.#logger.child({ speechId: handle.speechId }).debug("started playing the first time");
            this.emit(0 /* PLAYOUT_STARTED */);
            handle.synchronizer.segmentPlayoutStarted();
            firstFrame = false;
          }
          handle.pushedDuration += frame.samplesPerChannel / frame.sampleRate * 1e3;
          handle.synchronizer.pushAudio(frame);
          await this.#audioSource.captureFrame(frame);
          await this.#audioSource.waitForPlayout();
        }
        handle.synchronizer.close(false);
        resolve2();
      });
      try {
        await Promise.any([captureTask, handle.intFut.await]);
      } finally {
        cancel();
        resolve();
      }
    });
  }
  async close() {
    this.#closed = true;
    await this.#playoutTask;
  }
}
export {
  AgentPlayout,
  AgentPlayoutEvent,
  PlayoutHandle
};
//# sourceMappingURL=agent_playout.js.map