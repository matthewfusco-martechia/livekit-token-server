"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var agent_playout_exports = {};
__export(agent_playout_exports, {
  AgentPlayout: () => AgentPlayout,
  AgentPlayoutEvent: () => AgentPlayoutEvent,
  PlayoutHandle: () => PlayoutHandle
});
module.exports = __toCommonJS(agent_playout_exports);
var import_node_events = __toESM(require("node:events"), 1);
var import_log = require("../log.cjs");
var import_utils = require("../utils.cjs");
var import_agent_output = require("./agent_output.cjs");
var AgentPlayoutEvent = /* @__PURE__ */ ((AgentPlayoutEvent2) => {
  AgentPlayoutEvent2[AgentPlayoutEvent2["PLAYOUT_STARTED"] = 0] = "PLAYOUT_STARTED";
  AgentPlayoutEvent2[AgentPlayoutEvent2["PLAYOUT_STOPPED"] = 1] = "PLAYOUT_STOPPED";
  return AgentPlayoutEvent2;
})(AgentPlayoutEvent || {});
class PlayoutHandle {
  #speechId;
  #audioSource;
  playoutSource;
  totalPlayedTime;
  synchronizer;
  #interrupted = false;
  pushedDuration = 0;
  intFut = new import_utils.Future();
  doneFut = new import_utils.Future();
  constructor(speechId, audioSource, playoutSource, synchronizer) {
    this.#speechId = speechId;
    this.#audioSource = audioSource;
    this.playoutSource = playoutSource;
    this.synchronizer = synchronizer;
  }
  get speechId() {
    return this.#speechId;
  }
  get interrupted() {
    return this.#interrupted;
  }
  get timePlayed() {
    return this.totalPlayedTime || this.pushedDuration - this.#audioSource.queuedDuration;
  }
  get done() {
    return this.doneFut.done || this.#interrupted;
  }
  interrupt() {
    if (this.done) {
      return;
    }
    this.intFut.resolve();
    this.#interrupted = true;
  }
  join() {
    return this.doneFut;
  }
}
class AgentPlayout extends import_node_events.default {
  #closed = false;
  #audioSource;
  #targetVolume = 1;
  #playoutTask;
  #logger = (0, import_log.log)();
  constructor(audioSource) {
    super();
    this.#audioSource = audioSource;
  }
  get targetVolume() {
    return this.#targetVolume;
  }
  set targetVolume(vol) {
    this.#targetVolume = vol;
  }
  play(speechId, playoutSource, synchronizer) {
    if (this.#closed) {
      throw new Error("source closed");
    }
    const handle = new PlayoutHandle(speechId, this.#audioSource, playoutSource, synchronizer);
    this.#playoutTask = this.#playout(handle, this.#playoutTask);
    return handle;
  }
  #playout(handle, oldTask) {
    return new import_utils.CancellablePromise(async (resolve, _, onCancel) => {
      const cancel = () => {
        captureTask.cancel();
        handle.totalPlayedTime = handle.pushedDuration - this.#audioSource.queuedDuration;
        if (handle.interrupted || captureTask.error) {
          handle.synchronizer.close(true);
          this.#audioSource.clearQueue();
        }
        if (!firstFrame) {
          this.emit(1 /* PLAYOUT_STOPPED */, handle.interrupted);
        }
        handle.doneFut.resolve();
        this.#logger.child({ speechId: handle.speechId, interrupted: handle.interrupted }).debug("playout finished");
      };
      onCancel(() => {
        cancel();
      });
      if (oldTask) {
        await (0, import_utils.gracefullyCancel)(oldTask);
      }
      if (this.#audioSource.queuedDuration > 0) {
        this.#logger.child({ speechId: handle.speechId, queuedDuration: this.#audioSource.queuedDuration }).warn("new playout while the source is still playing");
      }
      let firstFrame = true;
      const captureTask = new import_utils.CancellablePromise(async (resolve2, _2, onCancel2) => {
        let cancelled = false;
        onCancel2(() => {
          cancelled = true;
        });
        for await (const frame of handle.playoutSource) {
          if (cancelled || frame === import_agent_output.SynthesisHandle.FLUSH_SENTINEL) {
            break;
          }
          if (firstFrame) {
            this.#logger.child({ speechId: handle.speechId }).debug("started playing the first time");
            this.emit(0 /* PLAYOUT_STARTED */);
            handle.synchronizer.segmentPlayoutStarted();
            firstFrame = false;
          }
          handle.pushedDuration += frame.samplesPerChannel / frame.sampleRate * 1e3;
          handle.synchronizer.pushAudio(frame);
          await this.#audioSource.captureFrame(frame);
          await this.#audioSource.waitForPlayout();
        }
        handle.synchronizer.close(false);
        resolve2();
      });
      try {
        await Promise.any([captureTask, handle.intFut.await]);
      } finally {
        cancel();
        resolve();
      }
    });
  }
  async close() {
    this.#closed = true;
    await this.#playoutTask;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AgentPlayout,
  AgentPlayoutEvent,
  PlayoutHandle
});
//# sourceMappingURL=agent_playout.cjs.map