import { Room, RoomEvent } from "@livekit/rtc-node";
import { randomUUID } from "node:crypto";
import { EventEmitter, once } from "node:events";
import { pathToFileURL } from "node:url";
import { isAgent } from "../generator.js";
import { CurrentJobContext, JobContext, JobProcess } from "../job.js";
import { initializeLogger, log } from "../log.js";
import { defaultInitializeProcessFunc } from "../worker.js";
const ORPHANED_TIMEOUT = 15 * 1e3;
class PendingInference {
  promise = new Promise((resolve) => {
    this.resolve = resolve;
  });
  resolve(arg) {
    arg;
  }
}
class InfClient {
  #requests = {};
  constructor() {
    process.on("message", (msg) => {
      switch (msg.case) {
        case "inferenceResponse":
          const fut = this.#requests[msg.value.requestId];
          delete this.#requests[msg.value.requestId];
          if (!fut) {
            log().child({ resp: msg.value }).warn("received unexpected inference response");
            return;
          }
          fut.resolve(msg.value);
          break;
      }
    });
  }
  async doInference(method, data) {
    const requestId = "inference_job_" + randomUUID;
    process.send({ case: "inferenceRequest", value: { requestId, method, data } });
    this.#requests[requestId] = new PendingInference();
    const resp = await this.#requests[requestId].promise;
    if (resp.error) {
      throw new Error(`inference of ${method} failed: ${resp.error.message}`);
    }
    return resp.data;
  }
}
const startJob = (proc, func, info, closeEvent, logger) => {
  let connect = false;
  let shutdown = false;
  const room = new Room();
  room.on(RoomEvent.Disconnected, () => {
    closeEvent.emit("close", false);
  });
  const onConnect = () => {
    connect = true;
  };
  const onShutdown = (reason) => {
    shutdown = true;
    closeEvent.emit("close", true, reason);
  };
  const ctx = new JobContext(proc, info, room, onConnect, onShutdown, new InfClient());
  new CurrentJobContext(ctx);
  const task = new Promise(async () => {
    const unconnectedTimeout = setTimeout(() => {
      if (!(connect || shutdown)) {
        logger.warn(
          "room not connect after job_entry was called after 10 seconds, ",
          "did you forget to call ctx.connect()?"
        );
      }
    }, 1e4);
    func(ctx).finally(() => clearTimeout(unconnectedTimeout));
    await once(closeEvent, "close").then((close) => {
      logger.debug("shutting down");
      process.send({ case: "exiting", value: { reason: close[1] } });
    });
    await room.disconnect();
    logger.debug("disconnected from room");
    const shutdownTasks = [];
    for (const callback of ctx.shutdownCallbacks) {
      shutdownTasks.push(callback());
    }
    await Promise.all(shutdownTasks).catch(() => logger.error("error while shutting down the job"));
    process.send({ case: "done" });
    process.exit();
  });
  return { ctx, task };
};
(async () => {
  if (process.send) {
    const moduleFile = process.argv[2];
    const agent = await import(pathToFileURL(moduleFile).pathname).then((module) => {
      const agent2 = module.default;
      if (agent2 === void 0 || !isAgent(agent2)) {
        throw new Error(`Unable to load agent: Missing or invalid default export in ${moduleFile}`);
      }
      return agent2;
    });
    if (!agent.prewarm) {
      agent.prewarm = defaultInitializeProcessFunc;
    }
    process.on("SIGINT", () => {
    });
    await once(process, "message").then(([msg]) => {
      msg = msg;
      if (msg.case !== "initializeRequest") {
        throw new Error("first message must be InitializeRequest");
      }
      initializeLogger(msg.value.loggerOptions);
    });
    const proc = new JobProcess();
    let logger = log().child({ pid: proc.pid });
    logger.debug("initializing job runner");
    agent.prewarm(proc);
    logger.debug("job runner initialized");
    process.send({ case: "initializeResponse" });
    let job = void 0;
    const closeEvent = new EventEmitter();
    const orphanedTimeout = setTimeout(() => {
      logger.warn("process orphaned, shutting down");
      process.exit();
    }, ORPHANED_TIMEOUT);
    process.on("message", (msg) => {
      switch (msg.case) {
        case "pingRequest": {
          orphanedTimeout.refresh();
          process.send({
            case: "pongResponse",
            value: { lastTimestamp: msg.value.timestamp, timestamp: Date.now() }
          });
          break;
        }
        case "startJobRequest": {
          if (job) {
            throw new Error("job task already running");
          }
          logger = logger.child({ jobID: msg.value.runningJob.job.id });
          job = startJob(proc, agent.entry, msg.value.runningJob, closeEvent, logger);
          logger.debug("job started");
          break;
        }
        case "shutdownRequest": {
          if (!job) {
            break;
          }
          closeEvent.emit("close", "");
        }
      }
    });
  }
})();
//# sourceMappingURL=job_proc_lazy_main.js.map