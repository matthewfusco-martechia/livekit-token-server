{"version":3,"sources":["../src/vad.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { AudioFrame } from '@livekit/rtc-node';\nimport type { TypedEventEmitter as TypedEmitter } from '@livekit/typed-emitter';\nimport { EventEmitter } from 'node:events';\nimport type { VADMetrics } from './metrics/base.js';\nimport { AsyncIterableQueue } from './utils.js';\n\nexport enum VADEventType {\n  START_OF_SPEECH,\n  INFERENCE_DONE,\n  END_OF_SPEECH,\n  METRICS_COLLECTED,\n}\n\nexport interface VADEvent {\n  /** Type of the VAD event (e.g., start of speech, end of speech, inference done). */\n  type: VADEventType;\n  /**\n   * Index of the audio sample where the event occurred, relative to the inference sample rate.\n   */\n  samplesIndex: number;\n  /** Timestamp when the event was fired. */\n  timestamp: number;\n  /** Duration of the speech segment. */\n  speechDuration: number;\n  /** Duration of the silence segment. */\n  silenceDuration: number;\n  /**\n   * List of audio frames associated with the speech.\n   *\n   * @remarks\n   * - For `start_of_speech` events, this contains the audio chunks that triggered the detection.\n   * - For `inference_done` events, this contains the audio chunks that were processed.\n   * - For `end_of_speech` events, this contains the complete user speech.\n   */\n  frames: AudioFrame[];\n  /** Probability that speech is present (only for `INFERENCE_DONE` events). */\n  probability: number;\n  /** Time taken to perform the inference, in seconds (only for `INFERENCE_DONE` events). */\n  inferenceDuration: number;\n  /** Indicates whether speech was detected in the frames. */\n  speaking: boolean;\n  /** Threshold used to detect silence. */\n  rawAccumulatedSilence: number;\n  /** Threshold used to detect speech. */\n  rawAccumulatedSpeech: number;\n}\n\nexport interface VADCapabilities {\n  updateInterval: number;\n}\n\nexport type VADCallbacks = {\n  [VADEventType.METRICS_COLLECTED]: (metrics: VADMetrics) => void;\n};\n\nexport abstract class VAD extends (EventEmitter as new () => TypedEmitter<VADCallbacks>) {\n  #capabilities: VADCapabilities;\n  abstract label: string;\n\n  constructor(capabilities: VADCapabilities) {\n    super();\n    this.#capabilities = capabilities;\n  }\n\n  get capabilities(): VADCapabilities {\n    return this.#capabilities;\n  }\n\n  /**\n   * Returns a {@link VADStream} that can be used to push audio frames and receive VAD events.\n   */\n  abstract stream(): VADStream;\n}\n\nexport abstract class VADStream implements AsyncIterableIterator<VADEvent> {\n  protected static readonly FLUSH_SENTINEL = Symbol('FLUSH_SENTINEL');\n  protected input = new AsyncIterableQueue<AudioFrame | typeof VADStream.FLUSH_SENTINEL>();\n  protected queue = new AsyncIterableQueue<VADEvent>();\n  protected output = new AsyncIterableQueue<VADEvent>();\n  protected closed = false;\n  #vad: VAD;\n  #lastActivityTime = BigInt(0);\n\n  constructor(vad: VAD) {\n    this.#vad = vad;\n    this.monitorMetrics();\n  }\n\n  protected async monitorMetrics() {\n    let inferenceDurationTotal = 0;\n    let inferenceCount = 0;\n\n    for await (const event of this.queue) {\n      this.output.put(event);\n      switch (event.type) {\n        case VADEventType.START_OF_SPEECH:\n          inferenceCount++;\n          if (inferenceCount >= 1 / this.#vad.capabilities.updateInterval) {\n            this.#vad.emit(VADEventType.METRICS_COLLECTED, {\n              timestamp: Date.now(),\n              idleTime: Math.trunc(\n                Number((process.hrtime.bigint() - this.#lastActivityTime) / BigInt(1000000)),\n              ),\n              inferenceDurationTotal,\n              inferenceCount,\n              label: this.#vad.label,\n            });\n\n            inferenceCount = 0;\n            inferenceDurationTotal = 0;\n          }\n          break;\n        case VADEventType.INFERENCE_DONE:\n        case VADEventType.END_OF_SPEECH:\n          this.#lastActivityTime = process.hrtime.bigint();\n          break;\n      }\n    }\n    this.output.close();\n  }\n\n  pushFrame(frame: AudioFrame) {\n    if (this.input.closed) {\n      throw new Error('Input is closed');\n    }\n    if (this.closed) {\n      throw new Error('Stream is closed');\n    }\n    this.input.put(frame);\n  }\n\n  flush() {\n    if (this.input.closed) {\n      throw new Error('Input is closed');\n    }\n    if (this.closed) {\n      throw new Error('Stream is closed');\n    }\n    this.input.put(VADStream.FLUSH_SENTINEL);\n  }\n\n  endInput() {\n    if (this.input.closed) {\n      throw new Error('Input is closed');\n    }\n    if (this.closed) {\n      throw new Error('Stream is closed');\n    }\n    this.input.close();\n  }\n\n  next(): Promise<IteratorResult<VADEvent>> {\n    return this.output.next();\n  }\n\n  close() {\n    this.input.close();\n    this.queue.close();\n    this.output.close();\n    this.closed = true;\n  }\n\n  [Symbol.asyncIterator](): VADStream {\n    return this;\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA,yBAA6B;AAE7B,mBAAmC;AAE5B,IAAK,eAAL,kBAAKA,kBAAL;AACL,EAAAA,4BAAA;AACA,EAAAA,4BAAA;AACA,EAAAA,4BAAA;AACA,EAAAA,4BAAA;AAJU,SAAAA;AAAA,GAAA;AAiDL,MAAe,YAAa,gCAAsD;AAAA,EACvF;AAAA,EAGA,YAAY,cAA+B;AACzC,UAAM;AACN,SAAK,gBAAgB;AAAA,EACvB;AAAA,EAEA,IAAI,eAAgC;AAClC,WAAO,KAAK;AAAA,EACd;AAMF;AAEO,MAAe,UAAqD;AAAA,EACzE,OAA0B,iBAAiB,OAAO,gBAAgB;AAAA,EACxD,QAAQ,IAAI,gCAAiE;AAAA,EAC7E,QAAQ,IAAI,gCAA6B;AAAA,EACzC,SAAS,IAAI,gCAA6B;AAAA,EAC1C,SAAS;AAAA,EACnB;AAAA,EACA,oBAAoB,OAAO,CAAC;AAAA,EAE5B,YAAY,KAAU;AACpB,SAAK,OAAO;AACZ,SAAK,eAAe;AAAA,EACtB;AAAA,EAEA,MAAgB,iBAAiB;AAC/B,QAAI,yBAAyB;AAC7B,QAAI,iBAAiB;AAErB,qBAAiB,SAAS,KAAK,OAAO;AACpC,WAAK,OAAO,IAAI,KAAK;AACrB,cAAQ,MAAM,MAAM;AAAA,QAClB,KAAK;AACH;AACA,cAAI,kBAAkB,IAAI,KAAK,KAAK,aAAa,gBAAgB;AAC/D,iBAAK,KAAK,KAAK,2BAAgC;AAAA,cAC7C,WAAW,KAAK,IAAI;AAAA,cACpB,UAAU,KAAK;AAAA,gBACb,QAAQ,QAAQ,OAAO,OAAO,IAAI,KAAK,qBAAqB,OAAO,GAAO,CAAC;AAAA,cAC7E;AAAA,cACA;AAAA,cACA;AAAA,cACA,OAAO,KAAK,KAAK;AAAA,YACnB,CAAC;AAED,6BAAiB;AACjB,qCAAyB;AAAA,UAC3B;AACA;AAAA,QACF,KAAK;AAAA,QACL,KAAK;AACH,eAAK,oBAAoB,QAAQ,OAAO,OAAO;AAC/C;AAAA,MACJ;AAAA,IACF;AACA,SAAK,OAAO,MAAM;AAAA,EACpB;AAAA,EAEA,UAAU,OAAmB;AAC3B,QAAI,KAAK,MAAM,QAAQ;AACrB,YAAM,IAAI,MAAM,iBAAiB;AAAA,IACnC;AACA,QAAI,KAAK,QAAQ;AACf,YAAM,IAAI,MAAM,kBAAkB;AAAA,IACpC;AACA,SAAK,MAAM,IAAI,KAAK;AAAA,EACtB;AAAA,EAEA,QAAQ;AACN,QAAI,KAAK,MAAM,QAAQ;AACrB,YAAM,IAAI,MAAM,iBAAiB;AAAA,IACnC;AACA,QAAI,KAAK,QAAQ;AACf,YAAM,IAAI,MAAM,kBAAkB;AAAA,IACpC;AACA,SAAK,MAAM,IAAI,UAAU,cAAc;AAAA,EACzC;AAAA,EAEA,WAAW;AACT,QAAI,KAAK,MAAM,QAAQ;AACrB,YAAM,IAAI,MAAM,iBAAiB;AAAA,IACnC;AACA,QAAI,KAAK,QAAQ;AACf,YAAM,IAAI,MAAM,kBAAkB;AAAA,IACpC;AACA,SAAK,MAAM,MAAM;AAAA,EACnB;AAAA,EAEA,OAA0C;AACxC,WAAO,KAAK,OAAO,KAAK;AAAA,EAC1B;AAAA,EAEA,QAAQ;AACN,SAAK,MAAM,MAAM;AACjB,SAAK,MAAM,MAAM;AACjB,SAAK,OAAO,MAAM;AAClB,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,CAAC,OAAO,aAAa,IAAe;AAClC,WAAO;AAAA,EACT;AACF;","names":["VADEventType"]}