{"version":3,"sources":["../../src/tts/tts.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { AudioFrame } from '@livekit/rtc-node';\nimport type { TypedEventEmitter as TypedEmitter } from '@livekit/typed-emitter';\nimport { EventEmitter } from 'node:events';\nimport type { TTSMetrics } from '../metrics/base.js';\nimport { AsyncIterableQueue, mergeFrames } from '../utils.js';\n\n/** SynthesizedAudio is a packet of speech synthesis as returned by the TTS. */\nexport interface SynthesizedAudio {\n  /** Request ID (one segment could be made up of multiple requests) */\n  requestId: string;\n  /** Segment ID, each segment is separated by a flush */\n  segmentId: string;\n  /** Synthesized audio frame */\n  frame: AudioFrame;\n  /** Current segment of the synthesized audio */\n  deltaText?: string;\n  /** Whether this is the last frame of the segment (streaming only) */\n  final: boolean;\n}\n\n/**\n * Describes the capabilities of the TTS provider.\n *\n * @remarks\n * At present, only `streaming` is supplied to this interface, and the framework only supports\n * providers that do have a streaming endpoint.\n */\nexport interface TTSCapabilities {\n  streaming: boolean;\n}\n\nexport enum TTSEvent {\n  METRICS_COLLECTED,\n}\n\nexport type TTSCallbacks = {\n  [TTSEvent.METRICS_COLLECTED]: (metrics: TTSMetrics) => void;\n};\n\n/**\n * An instance of a text-to-speech adapter.\n *\n * @remarks\n * This class is abstract, and as such cannot be used directly. Instead, use a provider plugin that\n * exports its own child TTS class, which inherits this class's methods.\n */\nexport abstract class TTS extends (EventEmitter as new () => TypedEmitter<TTSCallbacks>) {\n  #capabilities: TTSCapabilities;\n  #sampleRate: number;\n  #numChannels: number;\n  abstract label: string;\n\n  constructor(sampleRate: number, numChannels: number, capabilities: TTSCapabilities) {\n    super();\n    this.#capabilities = capabilities;\n    this.#sampleRate = sampleRate;\n    this.#numChannels = numChannels;\n  }\n\n  /** Returns this TTS's capabilities */\n  get capabilities(): TTSCapabilities {\n    return this.#capabilities;\n  }\n\n  /** Returns the sample rate of audio frames returned by this TTS */\n  get sampleRate(): number {\n    return this.#sampleRate;\n  }\n\n  /** Returns the channel count of audio frames returned by this TTS */\n  get numChannels(): number {\n    return this.#numChannels;\n  }\n\n  /**\n   * Receives text and returns synthesis in the form of a {@link ChunkedStream}\n   */\n  abstract synthesize(text: string): ChunkedStream;\n\n  /**\n   * Returns a {@link SynthesizeStream} that can be used to push text and receive audio data\n   */\n  abstract stream(): SynthesizeStream;\n}\n\n/**\n * An instance of a text-to-speech stream, as an asynchronous iterable iterator.\n *\n * @example Looping through frames\n * ```ts\n * for await (const event of stream) {\n *   await source.captureFrame(event.frame);\n * }\n * ```\n *\n * @remarks\n * This class is abstract, and as such cannot be used directly. Instead, use a provider plugin that\n * exports its own child SynthesizeStream class, which inherits this class's methods.\n */\nexport abstract class SynthesizeStream\n  implements AsyncIterableIterator<SynthesizedAudio | typeof SynthesizeStream.END_OF_STREAM>\n{\n  protected static readonly FLUSH_SENTINEL = Symbol('FLUSH_SENTINEL');\n  static readonly END_OF_STREAM = Symbol('END_OF_STREAM');\n  protected input = new AsyncIterableQueue<string | typeof SynthesizeStream.FLUSH_SENTINEL>();\n  protected queue = new AsyncIterableQueue<\n    SynthesizedAudio | typeof SynthesizeStream.END_OF_STREAM\n  >();\n  protected output = new AsyncIterableQueue<\n    SynthesizedAudio | typeof SynthesizeStream.END_OF_STREAM\n  >();\n  protected closed = false;\n  abstract label: string;\n  #tts: TTS;\n  #metricsPendingTexts: string[] = [];\n  #metricsText = '';\n  #monitorMetricsTask?: Promise<void>;\n\n  constructor(tts: TTS) {\n    this.#tts = tts;\n  }\n\n  protected async monitorMetrics() {\n    const startTime = process.hrtime.bigint();\n    let audioDuration = 0;\n    let ttfb: bigint | undefined;\n    let requestId = '';\n\n    const emit = () => {\n      if (this.#metricsPendingTexts.length) {\n        const text = this.#metricsPendingTexts.shift()!;\n        const duration = process.hrtime.bigint() - startTime;\n        const metrics: TTSMetrics = {\n          timestamp: Date.now(),\n          requestId,\n          ttfb: Math.trunc(Number(ttfb! / BigInt(1000000))),\n          duration: Math.trunc(Number(duration / BigInt(1000000))),\n          charactersCount: text.length,\n          audioDuration,\n          cancelled: false, // XXX(nbsp)\n          label: this.label,\n          streamed: false,\n        };\n        this.#tts.emit(TTSEvent.METRICS_COLLECTED, metrics);\n      }\n    };\n\n    for await (const audio of this.queue) {\n      this.output.put(audio);\n      if (audio === SynthesizeStream.END_OF_STREAM) continue;\n      requestId = audio.requestId;\n      if (!ttfb) {\n        ttfb = process.hrtime.bigint() - startTime;\n      }\n      audioDuration += audio.frame.samplesPerChannel / audio.frame.sampleRate;\n      if (audio.final) {\n        emit();\n      }\n    }\n\n    if (requestId) {\n      emit();\n    }\n    this.output.close();\n  }\n\n  /** Push a string of text to the TTS */\n  pushText(text: string) {\n    if (!this.#monitorMetricsTask) {\n      this.#monitorMetricsTask = this.monitorMetrics();\n    }\n    this.#metricsText += text;\n\n    if (this.input.closed) {\n      throw new Error('Input is closed');\n    }\n    if (this.closed) {\n      throw new Error('Stream is closed');\n    }\n    this.input.put(text);\n  }\n\n  /** Flush the TTS, causing it to process all pending text */\n  flush() {\n    if (this.#metricsText) {\n      this.#metricsPendingTexts.push(this.#metricsText);\n      this.#metricsText = '';\n    }\n    if (this.input.closed) {\n      throw new Error('Input is closed');\n    }\n    if (this.closed) {\n      throw new Error('Stream is closed');\n    }\n    this.input.put(SynthesizeStream.FLUSH_SENTINEL);\n  }\n\n  /** Mark the input as ended and forbid additional pushes */\n  endInput() {\n    if (this.input.closed) {\n      throw new Error('Input is closed');\n    }\n    if (this.closed) {\n      throw new Error('Stream is closed');\n    }\n    this.input.close();\n  }\n\n  next(): Promise<IteratorResult<SynthesizedAudio | typeof SynthesizeStream.END_OF_STREAM>> {\n    return this.output.next();\n  }\n\n  /** Close both the input and output of the TTS stream */\n  close() {\n    this.input.close();\n    this.output.close();\n    this.closed = true;\n  }\n\n  [Symbol.asyncIterator](): SynthesizeStream {\n    return this;\n  }\n}\n\n/**\n * An instance of a text-to-speech response, as an asynchronous iterable iterator.\n *\n * @example Looping through frames\n * ```ts\n * for await (const event of stream) {\n *   await source.captureFrame(event.frame);\n * }\n * ```\n *\n * @remarks\n * This class is abstract, and as such cannot be used directly. Instead, use a provider plugin that\n * exports its own child ChunkedStream class, which inherits this class's methods.\n */\nexport abstract class ChunkedStream implements AsyncIterableIterator<SynthesizedAudio> {\n  protected queue = new AsyncIterableQueue<SynthesizedAudio>();\n  protected output = new AsyncIterableQueue<SynthesizedAudio>();\n  protected closed = false;\n  abstract label: string;\n  #text: string;\n  #tts: TTS;\n\n  constructor(text: string, tts: TTS) {\n    this.#text = text;\n    this.#tts = tts;\n\n    this.monitorMetrics();\n  }\n\n  protected async monitorMetrics() {\n    const startTime = process.hrtime.bigint();\n    let audioDuration = 0;\n    let ttfb: bigint | undefined;\n    let requestId = '';\n\n    for await (const audio of this.queue) {\n      this.output.put(audio);\n      requestId = audio.requestId;\n      if (!ttfb) {\n        ttfb = process.hrtime.bigint() - startTime;\n      }\n      audioDuration += audio.frame.samplesPerChannel / audio.frame.sampleRate;\n    }\n    this.output.close();\n\n    const duration = process.hrtime.bigint() - startTime;\n    const metrics: TTSMetrics = {\n      timestamp: Date.now(),\n      requestId,\n      ttfb: Math.trunc(Number(ttfb! / BigInt(1000000))),\n      duration: Math.trunc(Number(duration / BigInt(1000000))),\n      charactersCount: this.#text.length,\n      audioDuration,\n      cancelled: false, // XXX(nbsp)\n      label: this.label,\n      streamed: false,\n    };\n    this.#tts.emit(TTSEvent.METRICS_COLLECTED, metrics);\n  }\n\n  /** Collect every frame into one in a single call */\n  async collect(): Promise<AudioFrame> {\n    const frames = [];\n    for await (const event of this) {\n      frames.push(event.frame);\n    }\n    return mergeFrames(frames);\n  }\n\n  next(): Promise<IteratorResult<SynthesizedAudio>> {\n    return this.output.next();\n  }\n\n  /** Close both the input and output of the TTS stream */\n  close() {\n    this.queue.close();\n    this.output.close();\n    this.closed = true;\n  }\n\n  [Symbol.asyncIterator](): ChunkedStream {\n    return this;\n  }\n}\n"],"mappings":"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","names":["TTSEvent"]}