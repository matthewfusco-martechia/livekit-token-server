"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var tts_exports = {};
__export(tts_exports, {
  ChunkedStream: () => ChunkedStream,
  SynthesizeStream: () => SynthesizeStream,
  TTS: () => TTS,
  TTSEvent: () => TTSEvent
});
module.exports = __toCommonJS(tts_exports);
var import_node_events = require("node:events");
var import_utils = require("../utils.cjs");
var TTSEvent = /* @__PURE__ */ ((TTSEvent2) => {
  TTSEvent2[TTSEvent2["METRICS_COLLECTED"] = 0] = "METRICS_COLLECTED";
  return TTSEvent2;
})(TTSEvent || {});
class TTS extends import_node_events.EventEmitter {
  #capabilities;
  #sampleRate;
  #numChannels;
  constructor(sampleRate, numChannels, capabilities) {
    super();
    this.#capabilities = capabilities;
    this.#sampleRate = sampleRate;
    this.#numChannels = numChannels;
  }
  /** Returns this TTS's capabilities */
  get capabilities() {
    return this.#capabilities;
  }
  /** Returns the sample rate of audio frames returned by this TTS */
  get sampleRate() {
    return this.#sampleRate;
  }
  /** Returns the channel count of audio frames returned by this TTS */
  get numChannels() {
    return this.#numChannels;
  }
}
class SynthesizeStream {
  static FLUSH_SENTINEL = Symbol("FLUSH_SENTINEL");
  static END_OF_STREAM = Symbol("END_OF_STREAM");
  input = new import_utils.AsyncIterableQueue();
  queue = new import_utils.AsyncIterableQueue();
  output = new import_utils.AsyncIterableQueue();
  closed = false;
  #tts;
  #metricsPendingTexts = [];
  #metricsText = "";
  #monitorMetricsTask;
  constructor(tts) {
    this.#tts = tts;
  }
  async monitorMetrics() {
    const startTime = process.hrtime.bigint();
    let audioDuration = 0;
    let ttfb;
    let requestId = "";
    const emit = () => {
      if (this.#metricsPendingTexts.length) {
        const text = this.#metricsPendingTexts.shift();
        const duration = process.hrtime.bigint() - startTime;
        const metrics = {
          timestamp: Date.now(),
          requestId,
          ttfb: Math.trunc(Number(ttfb / BigInt(1e6))),
          duration: Math.trunc(Number(duration / BigInt(1e6))),
          charactersCount: text.length,
          audioDuration,
          cancelled: false,
          // XXX(nbsp)
          label: this.label,
          streamed: false
        };
        this.#tts.emit(0 /* METRICS_COLLECTED */, metrics);
      }
    };
    for await (const audio of this.queue) {
      this.output.put(audio);
      if (audio === SynthesizeStream.END_OF_STREAM) continue;
      requestId = audio.requestId;
      if (!ttfb) {
        ttfb = process.hrtime.bigint() - startTime;
      }
      audioDuration += audio.frame.samplesPerChannel / audio.frame.sampleRate;
      if (audio.final) {
        emit();
      }
    }
    if (requestId) {
      emit();
    }
    this.output.close();
  }
  /** Push a string of text to the TTS */
  pushText(text) {
    if (!this.#monitorMetricsTask) {
      this.#monitorMetricsTask = this.monitorMetrics();
    }
    this.#metricsText += text;
    if (this.input.closed) {
      throw new Error("Input is closed");
    }
    if (this.closed) {
      throw new Error("Stream is closed");
    }
    this.input.put(text);
  }
  /** Flush the TTS, causing it to process all pending text */
  flush() {
    if (this.#metricsText) {
      this.#metricsPendingTexts.push(this.#metricsText);
      this.#metricsText = "";
    }
    if (this.input.closed) {
      throw new Error("Input is closed");
    }
    if (this.closed) {
      throw new Error("Stream is closed");
    }
    this.input.put(SynthesizeStream.FLUSH_SENTINEL);
  }
  /** Mark the input as ended and forbid additional pushes */
  endInput() {
    if (this.input.closed) {
      throw new Error("Input is closed");
    }
    if (this.closed) {
      throw new Error("Stream is closed");
    }
    this.input.close();
  }
  next() {
    return this.output.next();
  }
  /** Close both the input and output of the TTS stream */
  close() {
    this.input.close();
    this.output.close();
    this.closed = true;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
}
class ChunkedStream {
  queue = new import_utils.AsyncIterableQueue();
  output = new import_utils.AsyncIterableQueue();
  closed = false;
  #text;
  #tts;
  constructor(text, tts) {
    this.#text = text;
    this.#tts = tts;
    this.monitorMetrics();
  }
  async monitorMetrics() {
    const startTime = process.hrtime.bigint();
    let audioDuration = 0;
    let ttfb;
    let requestId = "";
    for await (const audio of this.queue) {
      this.output.put(audio);
      requestId = audio.requestId;
      if (!ttfb) {
        ttfb = process.hrtime.bigint() - startTime;
      }
      audioDuration += audio.frame.samplesPerChannel / audio.frame.sampleRate;
    }
    this.output.close();
    const duration = process.hrtime.bigint() - startTime;
    const metrics = {
      timestamp: Date.now(),
      requestId,
      ttfb: Math.trunc(Number(ttfb / BigInt(1e6))),
      duration: Math.trunc(Number(duration / BigInt(1e6))),
      charactersCount: this.#text.length,
      audioDuration,
      cancelled: false,
      // XXX(nbsp)
      label: this.label,
      streamed: false
    };
    this.#tts.emit(0 /* METRICS_COLLECTED */, metrics);
  }
  /** Collect every frame into one in a single call */
  async collect() {
    const frames = [];
    for await (const event of this) {
      frames.push(event.frame);
    }
    return (0, import_utils.mergeFrames)(frames);
  }
  next() {
    return this.output.next();
  }
  /** Close both the input and output of the TTS stream */
  close() {
    this.queue.close();
    this.output.close();
    this.closed = true;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ChunkedStream,
  SynthesizeStream,
  TTS,
  TTSEvent
});
//# sourceMappingURL=tts.cjs.map