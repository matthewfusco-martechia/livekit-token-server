{"version":3,"sources":["../../src/tts/stream_adapter.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { SentenceStream, SentenceTokenizer } from '../tokenize/index.js';\nimport type { ChunkedStream } from './tts.js';\nimport { SynthesizeStream, TTS, TTSEvent } from './tts.js';\n\nexport class StreamAdapter extends TTS {\n  #tts: TTS;\n  #sentenceTokenizer: SentenceTokenizer;\n  label: string;\n\n  constructor(tts: TTS, sentenceTokenizer: SentenceTokenizer) {\n    super(tts.sampleRate, tts.numChannels, { streaming: true });\n    this.#tts = tts;\n    this.#sentenceTokenizer = sentenceTokenizer;\n    this.label = this.#tts.label;\n    this.label = `tts.StreamAdapter<${this.#tts.label}>`;\n\n    this.#tts.on(TTSEvent.METRICS_COLLECTED, (metrics) => {\n      this.emit(TTSEvent.METRICS_COLLECTED, metrics);\n    });\n  }\n\n  synthesize(text: string): ChunkedStream {\n    return this.#tts.synthesize(text);\n  }\n\n  stream(): StreamAdapterWrapper {\n    return new StreamAdapterWrapper(this.#tts, this.#sentenceTokenizer);\n  }\n}\n\nexport class StreamAdapterWrapper extends SynthesizeStream {\n  #tts: TTS;\n  #sentenceStream: SentenceStream;\n  label: string;\n\n  constructor(tts: TTS, sentenceTokenizer: SentenceTokenizer) {\n    super(tts);\n    this.#tts = tts;\n    this.#sentenceStream = sentenceTokenizer.stream();\n    this.label = `tts.StreamAdapterWrapper<${this.#tts.label}>`;\n\n    this.#run();\n  }\n\n  async monitorMetrics() {\n    return; // do nothing\n  }\n\n  async #run() {\n    const forwardInput = async () => {\n      for await (const input of this.input) {\n        if (input === SynthesizeStream.FLUSH_SENTINEL) {\n          this.#sentenceStream.flush();\n        } else {\n          this.#sentenceStream.pushText(input);\n        }\n      }\n      this.#sentenceStream.endInput();\n      this.#sentenceStream.close();\n    };\n\n    const synthesize = async () => {\n      for await (const ev of this.#sentenceStream) {\n        for await (const audio of this.#tts.synthesize(ev.token)) {\n          this.output.put(audio);\n        }\n      }\n      this.output.put(SynthesizeStream.END_OF_STREAM);\n    };\n\n    Promise.all([forwardInput(), synthesize()]);\n  }\n}\n"],"mappings":"AAKA,SAAS,kBAAkB,KAAK,gBAAgB;AAEzC,MAAM,sBAAsB,IAAI;AAAA,EACrC;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YAAY,KAAU,mBAAsC;AAC1D,UAAM,IAAI,YAAY,IAAI,aAAa,EAAE,WAAW,KAAK,CAAC;AAC1D,SAAK,OAAO;AACZ,SAAK,qBAAqB;AAC1B,SAAK,QAAQ,KAAK,KAAK;AACvB,SAAK,QAAQ,qBAAqB,KAAK,KAAK,KAAK;AAEjD,SAAK,KAAK,GAAG,SAAS,mBAAmB,CAAC,YAAY;AACpD,WAAK,KAAK,SAAS,mBAAmB,OAAO;AAAA,IAC/C,CAAC;AAAA,EACH;AAAA,EAEA,WAAW,MAA6B;AACtC,WAAO,KAAK,KAAK,WAAW,IAAI;AAAA,EAClC;AAAA,EAEA,SAA+B;AAC7B,WAAO,IAAI,qBAAqB,KAAK,MAAM,KAAK,kBAAkB;AAAA,EACpE;AACF;AAEO,MAAM,6BAA6B,iBAAiB;AAAA,EACzD;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YAAY,KAAU,mBAAsC;AAC1D,UAAM,GAAG;AACT,SAAK,OAAO;AACZ,SAAK,kBAAkB,kBAAkB,OAAO;AAChD,SAAK,QAAQ,4BAA4B,KAAK,KAAK,KAAK;AAExD,SAAK,KAAK;AAAA,EACZ;AAAA,EAEA,MAAM,iBAAiB;AACrB;AAAA,EACF;AAAA,EAEA,MAAM,OAAO;AACX,UAAM,eAAe,YAAY;AAC/B,uBAAiB,SAAS,KAAK,OAAO;AACpC,YAAI,UAAU,iBAAiB,gBAAgB;AAC7C,eAAK,gBAAgB,MAAM;AAAA,QAC7B,OAAO;AACL,eAAK,gBAAgB,SAAS,KAAK;AAAA,QACrC;AAAA,MACF;AACA,WAAK,gBAAgB,SAAS;AAC9B,WAAK,gBAAgB,MAAM;AAAA,IAC7B;AAEA,UAAM,aAAa,YAAY;AAC7B,uBAAiB,MAAM,KAAK,iBAAiB;AAC3C,yBAAiB,SAAS,KAAK,KAAK,WAAW,GAAG,KAAK,GAAG;AACxD,eAAK,OAAO,IAAI,KAAK;AAAA,QACvB;AAAA,MACF;AACA,WAAK,OAAO,IAAI,iBAAiB,aAAa;AAAA,IAChD;AAEA,YAAQ,IAAI,CAAC,aAAa,GAAG,WAAW,CAAC,CAAC;AAAA,EAC5C;AACF;","names":[]}