import { EventEmitter } from "node:events";
import { AsyncIterableQueue, mergeFrames } from "../utils.js";
var TTSEvent = /* @__PURE__ */ ((TTSEvent2) => {
  TTSEvent2[TTSEvent2["METRICS_COLLECTED"] = 0] = "METRICS_COLLECTED";
  return TTSEvent2;
})(TTSEvent || {});
class TTS extends EventEmitter {
  #capabilities;
  #sampleRate;
  #numChannels;
  constructor(sampleRate, numChannels, capabilities) {
    super();
    this.#capabilities = capabilities;
    this.#sampleRate = sampleRate;
    this.#numChannels = numChannels;
  }
  /** Returns this TTS's capabilities */
  get capabilities() {
    return this.#capabilities;
  }
  /** Returns the sample rate of audio frames returned by this TTS */
  get sampleRate() {
    return this.#sampleRate;
  }
  /** Returns the channel count of audio frames returned by this TTS */
  get numChannels() {
    return this.#numChannels;
  }
}
class SynthesizeStream {
  static FLUSH_SENTINEL = Symbol("FLUSH_SENTINEL");
  static END_OF_STREAM = Symbol("END_OF_STREAM");
  input = new AsyncIterableQueue();
  queue = new AsyncIterableQueue();
  output = new AsyncIterableQueue();
  closed = false;
  #tts;
  #metricsPendingTexts = [];
  #metricsText = "";
  #monitorMetricsTask;
  constructor(tts) {
    this.#tts = tts;
  }
  async monitorMetrics() {
    const startTime = process.hrtime.bigint();
    let audioDuration = 0;
    let ttfb;
    let requestId = "";
    const emit = () => {
      if (this.#metricsPendingTexts.length) {
        const text = this.#metricsPendingTexts.shift();
        const duration = process.hrtime.bigint() - startTime;
        const metrics = {
          timestamp: Date.now(),
          requestId,
          ttfb: Math.trunc(Number(ttfb / BigInt(1e6))),
          duration: Math.trunc(Number(duration / BigInt(1e6))),
          charactersCount: text.length,
          audioDuration,
          cancelled: false,
          // XXX(nbsp)
          label: this.label,
          streamed: false
        };
        this.#tts.emit(0 /* METRICS_COLLECTED */, metrics);
      }
    };
    for await (const audio of this.queue) {
      this.output.put(audio);
      if (audio === SynthesizeStream.END_OF_STREAM) continue;
      requestId = audio.requestId;
      if (!ttfb) {
        ttfb = process.hrtime.bigint() - startTime;
      }
      audioDuration += audio.frame.samplesPerChannel / audio.frame.sampleRate;
      if (audio.final) {
        emit();
      }
    }
    if (requestId) {
      emit();
    }
    this.output.close();
  }
  /** Push a string of text to the TTS */
  pushText(text) {
    if (!this.#monitorMetricsTask) {
      this.#monitorMetricsTask = this.monitorMetrics();
    }
    this.#metricsText += text;
    if (this.input.closed) {
      throw new Error("Input is closed");
    }
    if (this.closed) {
      throw new Error("Stream is closed");
    }
    this.input.put(text);
  }
  /** Flush the TTS, causing it to process all pending text */
  flush() {
    if (this.#metricsText) {
      this.#metricsPendingTexts.push(this.#metricsText);
      this.#metricsText = "";
    }
    if (this.input.closed) {
      throw new Error("Input is closed");
    }
    if (this.closed) {
      throw new Error("Stream is closed");
    }
    this.input.put(SynthesizeStream.FLUSH_SENTINEL);
  }
  /** Mark the input as ended and forbid additional pushes */
  endInput() {
    if (this.input.closed) {
      throw new Error("Input is closed");
    }
    if (this.closed) {
      throw new Error("Stream is closed");
    }
    this.input.close();
  }
  next() {
    return this.output.next();
  }
  /** Close both the input and output of the TTS stream */
  close() {
    this.input.close();
    this.output.close();
    this.closed = true;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
}
class ChunkedStream {
  queue = new AsyncIterableQueue();
  output = new AsyncIterableQueue();
  closed = false;
  #text;
  #tts;
  constructor(text, tts) {
    this.#text = text;
    this.#tts = tts;
    this.monitorMetrics();
  }
  async monitorMetrics() {
    const startTime = process.hrtime.bigint();
    let audioDuration = 0;
    let ttfb;
    let requestId = "";
    for await (const audio of this.queue) {
      this.output.put(audio);
      requestId = audio.requestId;
      if (!ttfb) {
        ttfb = process.hrtime.bigint() - startTime;
      }
      audioDuration += audio.frame.samplesPerChannel / audio.frame.sampleRate;
    }
    this.output.close();
    const duration = process.hrtime.bigint() - startTime;
    const metrics = {
      timestamp: Date.now(),
      requestId,
      ttfb: Math.trunc(Number(ttfb / BigInt(1e6))),
      duration: Math.trunc(Number(duration / BigInt(1e6))),
      charactersCount: this.#text.length,
      audioDuration,
      cancelled: false,
      // XXX(nbsp)
      label: this.label,
      streamed: false
    };
    this.#tts.emit(0 /* METRICS_COLLECTED */, metrics);
  }
  /** Collect every frame into one in a single call */
  async collect() {
    const frames = [];
    for await (const event of this) {
      frames.push(event.frame);
    }
    return mergeFrames(frames);
  }
  next() {
    return this.output.next();
  }
  /** Close both the input and output of the TTS stream */
  close() {
    this.queue.close();
    this.output.close();
    this.closed = true;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
}
export {
  ChunkedStream,
  SynthesizeStream,
  TTS,
  TTSEvent
};
//# sourceMappingURL=tts.js.map