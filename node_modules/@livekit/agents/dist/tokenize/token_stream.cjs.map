{"version":3,"sources":["../../src/tokenize/token_stream.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport { randomUUID } from 'node:crypto';\nimport { AsyncIterableQueue } from '../utils.js';\nimport type { TokenData } from './tokenizer.js';\nimport { SentenceStream, WordStream } from './tokenizer.js';\n\ntype TokenizeFunc = (x: string) => string[] | [string, number, number][];\n\nexport class BufferedTokenStream implements AsyncIterableIterator<TokenData> {\n  protected queue = new AsyncIterableQueue<TokenData>();\n  protected closed = false;\n\n  #func: TokenizeFunc;\n  #minTokenLength: number;\n  #minContextLength: number;\n  #bufTokens: string[] = [];\n  #inBuf = '';\n  #outBuf = '';\n  #currentSegmentId: string;\n\n  constructor(func: TokenizeFunc, minTokenLength: number, minContextLength: number) {\n    this.#func = func;\n    this.#minTokenLength = minTokenLength;\n    this.#minContextLength = minContextLength;\n\n    this.#currentSegmentId = randomUUID();\n  }\n\n  /** Push a string of text into the token stream */\n  pushText(text: string) {\n    if (this.closed) {\n      throw new Error('Stream is closed');\n    }\n\n    this.#inBuf += text;\n    if (this.#inBuf.length < this.#minContextLength) return;\n\n    while (true) {\n      const tokens = this.#func(this.#inBuf);\n      if (tokens.length <= 1) break;\n\n      if (this.#outBuf) this.#outBuf += ' ';\n\n      const tok = tokens.shift()!;\n      let tokText: string;\n      if (Array.isArray(tok)) {\n        tokText = tok[0];\n      } else {\n        tokText = tok;\n      }\n\n      this.#outBuf += tokText;\n\n      if (this.#outBuf.length >= this.#minTokenLength) {\n        this.queue.put({ token: this.#outBuf, segmentId: this.#currentSegmentId });\n        this.#outBuf = '';\n      }\n\n      if (typeof tok! !== 'string') {\n        this.#inBuf = this.#inBuf.slice(tok![2]);\n      } else {\n        this.#inBuf = this.#inBuf\n          .slice(Math.max(0, this.#inBuf.indexOf(tok)) + tok.length)\n          .trimStart();\n      }\n    }\n  }\n\n  /** Flush the stream, causing it to process all pending text */\n  flush() {\n    if (this.closed) {\n      throw new Error('Stream is closed');\n    }\n\n    if (this.#inBuf || this.#outBuf) {\n      const tokens = this.#func(this.#inBuf);\n      if (tokens) {\n        if (this.#outBuf) this.#outBuf += ' ';\n\n        if (Array.isArray(tokens[0])) {\n          this.#outBuf += tokens.map((tok) => tok[0]).join(' ');\n        } else {\n          this.#outBuf += tokens.join(' ');\n        }\n      }\n\n      if (this.#outBuf) {\n        this.queue.put({ token: this.#outBuf, segmentId: this.#currentSegmentId });\n      }\n\n      this.#currentSegmentId = randomUUID();\n    }\n\n    this.#inBuf = '';\n    this.#outBuf = '';\n  }\n\n  /** Mark the input as ended and forbid additional pushes */\n  endInput() {\n    if (this.closed) {\n      throw new Error('Stream is closed');\n    }\n    this.flush();\n    this.close();\n  }\n\n  next(): Promise<IteratorResult<TokenData>> {\n    return this.queue.next();\n  }\n\n  /** Close both the input and output of the token stream */\n  close() {\n    this.queue.close();\n    this.closed = true;\n  }\n\n  [Symbol.asyncIterator](): BufferedTokenStream {\n    return this;\n  }\n}\n\nexport class BufferedSentenceStream extends SentenceStream {\n  #stream: BufferedTokenStream;\n\n  constructor(func: TokenizeFunc, minTokenLength: number, minContextLength: number) {\n    super();\n    this.#stream = new BufferedTokenStream(func, minTokenLength, minContextLength);\n  }\n\n  pushText(text: string) {\n    this.#stream.pushText(text);\n  }\n\n  flush() {\n    this.#stream.flush();\n  }\n\n  close() {\n    super.close();\n    this.#stream.close();\n  }\n\n  next(): Promise<IteratorResult<TokenData>> {\n    return this.#stream.next();\n  }\n}\n\nexport class BufferedWordStream extends WordStream {\n  #stream: BufferedTokenStream;\n\n  constructor(func: TokenizeFunc, minTokenLength: number, minContextLength: number) {\n    super();\n    this.#stream = new BufferedTokenStream(func, minTokenLength, minContextLength);\n  }\n\n  pushText(text: string) {\n    this.#stream.pushText(text);\n  }\n\n  flush() {\n    this.#stream.flush();\n  }\n\n  endInput() {\n    this.#stream.endInput();\n  }\n\n  close() {\n    this.#stream.close();\n  }\n\n  next(): Promise<IteratorResult<TokenData>> {\n    return this.#stream.next();\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,yBAA2B;AAC3B,mBAAmC;AAEnC,uBAA2C;AAIpC,MAAM,oBAAgE;AAAA,EACjE,QAAQ,IAAI,gCAA8B;AAAA,EAC1C,SAAS;AAAA,EAEnB;AAAA,EACA;AAAA,EACA;AAAA,EACA,aAAuB,CAAC;AAAA,EACxB,SAAS;AAAA,EACT,UAAU;AAAA,EACV;AAAA,EAEA,YAAY,MAAoB,gBAAwB,kBAA0B;AAChF,SAAK,QAAQ;AACb,SAAK,kBAAkB;AACvB,SAAK,oBAAoB;AAEzB,SAAK,wBAAoB,+BAAW;AAAA,EACtC;AAAA;AAAA,EAGA,SAAS,MAAc;AACrB,QAAI,KAAK,QAAQ;AACf,YAAM,IAAI,MAAM,kBAAkB;AAAA,IACpC;AAEA,SAAK,UAAU;AACf,QAAI,KAAK,OAAO,SAAS,KAAK,kBAAmB;AAEjD,WAAO,MAAM;AACX,YAAM,SAAS,KAAK,MAAM,KAAK,MAAM;AACrC,UAAI,OAAO,UAAU,EAAG;AAExB,UAAI,KAAK,QAAS,MAAK,WAAW;AAElC,YAAM,MAAM,OAAO,MAAM;AACzB,UAAI;AACJ,UAAI,MAAM,QAAQ,GAAG,GAAG;AACtB,kBAAU,IAAI,CAAC;AAAA,MACjB,OAAO;AACL,kBAAU;AAAA,MACZ;AAEA,WAAK,WAAW;AAEhB,UAAI,KAAK,QAAQ,UAAU,KAAK,iBAAiB;AAC/C,aAAK,MAAM,IAAI,EAAE,OAAO,KAAK,SAAS,WAAW,KAAK,kBAAkB,CAAC;AACzE,aAAK,UAAU;AAAA,MACjB;AAEA,UAAI,OAAO,QAAS,UAAU;AAC5B,aAAK,SAAS,KAAK,OAAO,MAAM,IAAK,CAAC,CAAC;AAAA,MACzC,OAAO;AACL,aAAK,SAAS,KAAK,OAChB,MAAM,KAAK,IAAI,GAAG,KAAK,OAAO,QAAQ,GAAG,CAAC,IAAI,IAAI,MAAM,EACxD,UAAU;AAAA,MACf;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGA,QAAQ;AACN,QAAI,KAAK,QAAQ;AACf,YAAM,IAAI,MAAM,kBAAkB;AAAA,IACpC;AAEA,QAAI,KAAK,UAAU,KAAK,SAAS;AAC/B,YAAM,SAAS,KAAK,MAAM,KAAK,MAAM;AACrC,UAAI,QAAQ;AACV,YAAI,KAAK,QAAS,MAAK,WAAW;AAElC,YAAI,MAAM,QAAQ,OAAO,CAAC,CAAC,GAAG;AAC5B,eAAK,WAAW,OAAO,IAAI,CAAC,QAAQ,IAAI,CAAC,CAAC,EAAE,KAAK,GAAG;AAAA,QACtD,OAAO;AACL,eAAK,WAAW,OAAO,KAAK,GAAG;AAAA,QACjC;AAAA,MACF;AAEA,UAAI,KAAK,SAAS;AAChB,aAAK,MAAM,IAAI,EAAE,OAAO,KAAK,SAAS,WAAW,KAAK,kBAAkB,CAAC;AAAA,MAC3E;AAEA,WAAK,wBAAoB,+BAAW;AAAA,IACtC;AAEA,SAAK,SAAS;AACd,SAAK,UAAU;AAAA,EACjB;AAAA;AAAA,EAGA,WAAW;AACT,QAAI,KAAK,QAAQ;AACf,YAAM,IAAI,MAAM,kBAAkB;AAAA,IACpC;AACA,SAAK,MAAM;AACX,SAAK,MAAM;AAAA,EACb;AAAA,EAEA,OAA2C;AACzC,WAAO,KAAK,MAAM,KAAK;AAAA,EACzB;AAAA;AAAA,EAGA,QAAQ;AACN,SAAK,MAAM,MAAM;AACjB,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,CAAC,OAAO,aAAa,IAAyB;AAC5C,WAAO;AAAA,EACT;AACF;AAEO,MAAM,+BAA+B,gCAAe;AAAA,EACzD;AAAA,EAEA,YAAY,MAAoB,gBAAwB,kBAA0B;AAChF,UAAM;AACN,SAAK,UAAU,IAAI,oBAAoB,MAAM,gBAAgB,gBAAgB;AAAA,EAC/E;AAAA,EAEA,SAAS,MAAc;AACrB,SAAK,QAAQ,SAAS,IAAI;AAAA,EAC5B;AAAA,EAEA,QAAQ;AACN,SAAK,QAAQ,MAAM;AAAA,EACrB;AAAA,EAEA,QAAQ;AACN,UAAM,MAAM;AACZ,SAAK,QAAQ,MAAM;AAAA,EACrB;AAAA,EAEA,OAA2C;AACzC,WAAO,KAAK,QAAQ,KAAK;AAAA,EAC3B;AACF;AAEO,MAAM,2BAA2B,4BAAW;AAAA,EACjD;AAAA,EAEA,YAAY,MAAoB,gBAAwB,kBAA0B;AAChF,UAAM;AACN,SAAK,UAAU,IAAI,oBAAoB,MAAM,gBAAgB,gBAAgB;AAAA,EAC/E;AAAA,EAEA,SAAS,MAAc;AACrB,SAAK,QAAQ,SAAS,IAAI;AAAA,EAC5B;AAAA,EAEA,QAAQ;AACN,SAAK,QAAQ,MAAM;AAAA,EACrB;AAAA,EAEA,WAAW;AACT,SAAK,QAAQ,SAAS;AAAA,EACxB;AAAA,EAEA,QAAQ;AACN,SAAK,QAAQ,MAAM;AAAA,EACrB;AAAA,EAEA,OAA2C;AACzC,WAAO,KAAK,QAAQ,KAAK;AAAA,EAC3B;AACF;","names":[]}